{"ast":null,"code":"import _assertThisInitialized from \"/Users/mbalazs/projects/knox/knox-homepage-ui/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _createForOfIteratorHelper from \"/Users/mbalazs/projects/knox/knox-homepage-ui/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _toConsumableArray from \"/Users/mbalazs/projects/knox/knox-homepage-ui/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _defineProperty from \"/Users/mbalazs/projects/knox/knox-homepage-ui/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _inherits from \"/Users/mbalazs/projects/knox/knox-homepage-ui/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/mbalazs/projects/knox/knox-homepage-ui/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _createClass from \"/Users/mbalazs/projects/knox/knox-homepage-ui/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"/Users/mbalazs/projects/knox/knox-homepage-ui/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\n\n/**\n * @license Angular v5.2.11\n * (c) 2010-2018 Google, Inc. https://angular.io/\n * License: MIT\n */\nimport { APP_BASE_HREF, HashLocationStrategy, LOCATION_INITIALIZED, Location, LocationStrategy, PathLocationStrategy, PlatformLocation } from '@angular/common';\nimport { ANALYZE_FOR_ENTRY_COMPONENTS, APP_BOOTSTRAP_LISTENER, APP_INITIALIZER, ApplicationRef, Attribute, ChangeDetectorRef, Compiler, ComponentFactoryResolver, ContentChildren, Directive, ElementRef, EventEmitter, HostBinding, HostListener, Inject, Injectable, InjectionToken, Injector, Input, NgModule, NgModuleFactory, NgModuleFactoryLoader, NgModuleRef, NgProbeToken, Optional, Output, Renderer2, SkipSelf, SystemJsNgModuleLoader, Version, ViewContainerRef, isDevMode, ɵisObservable, ɵisPromise } from '@angular/core';\nimport { BehaviorSubject } from 'rxjs/BehaviorSubject';\nimport { Subject } from 'rxjs/Subject';\nimport { of } from 'rxjs/observable/of';\nimport { concatMap } from 'rxjs/operator/concatMap';\nimport { map } from 'rxjs/operator/map';\nimport { mergeMap } from 'rxjs/operator/mergeMap';\nimport { Observable } from 'rxjs/Observable';\nimport { from } from 'rxjs/observable/from';\nimport { _catch } from 'rxjs/operator/catch';\nimport { concatAll } from 'rxjs/operator/concatAll';\nimport { first } from 'rxjs/operator/first';\nimport { EmptyError } from 'rxjs/util/EmptyError';\nimport { fromPromise } from 'rxjs/observable/fromPromise';\nimport { every } from 'rxjs/operator/every';\nimport { last } from 'rxjs/operator/last';\nimport { mergeAll } from 'rxjs/operator/mergeAll';\nimport { reduce } from 'rxjs/operator/reduce';\nimport { ɵgetDOM } from '@angular/platform-browser';\nimport { filter } from 'rxjs/operator/filter';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * \\@whatItDoes Base for events the Router goes through, as opposed to events tied to a specific\n * Route. `RouterEvent`s will only be fired one time for any given navigation.\n *\n * Example:\n *\n * ```\n * class MyService {\n *   constructor(public router: Router, logger: Logger) {\n *     router.events.filter(e => e instanceof RouterEvent).subscribe(e => {\n *       logger.log(e.id, e.url);\n *     });\n *   }\n * }\n * ```\n *\n * \\@experimental\n */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/common';\n\nvar RouterEvent = /*#__PURE__*/_createClass(\n/**\n * @param {?} id\n * @param {?} url\n */\nfunction RouterEvent(id, url) {\n  _classCallCheck(this, RouterEvent);\n\n  this.id = id;\n  this.url = url;\n});\n/**\n * \\@whatItDoes Represents an event triggered when a navigation starts.\n *\n * \\@stable\n */\n\n\nvar NavigationStart = /*#__PURE__*/function (_RouterEvent) {\n  _inherits(NavigationStart, _RouterEvent);\n\n  var _super = _createSuper(NavigationStart);\n\n  function NavigationStart() {\n    _classCallCheck(this, NavigationStart);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(NavigationStart, [{\n    key: \"toString\",\n    value:\n    /**\n     * \\@docsNotRequired\n     * @return {?}\n     */\n    function toString() {\n      return \"NavigationStart(id: \".concat(this.id, \", url: '\").concat(this.url, \"')\");\n    }\n  }]);\n\n  return NavigationStart;\n}(RouterEvent);\n/**\n * \\@whatItDoes Represents an event triggered when a navigation ends successfully.\n *\n * \\@stable\n */\n\n\nvar NavigationEnd = /*#__PURE__*/function (_RouterEvent2) {\n  _inherits(NavigationEnd, _RouterEvent2);\n\n  var _super2 = _createSuper(NavigationEnd);\n\n  /**\n   * @param {?} id\n   * @param {?} url\n   * @param {?} urlAfterRedirects\n   */\n  function NavigationEnd(\n  /** @docsNotRequired */\n\n  /** @docsNotRequired */\n  id,\n  /** @docsNotRequired */\n\n  /** @docsNotRequired */\n  url, urlAfterRedirects) {\n    var _this;\n\n    _classCallCheck(this, NavigationEnd);\n\n    _this = _super2.call(this, id, url);\n    _this.urlAfterRedirects = urlAfterRedirects;\n    return _this;\n  }\n  /**\n   * \\@docsNotRequired\n   * @return {?}\n   */\n\n\n  _createClass(NavigationEnd, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"NavigationEnd(id: \".concat(this.id, \", url: '\").concat(this.url, \"', urlAfterRedirects: '\").concat(this.urlAfterRedirects, \"')\");\n    }\n  }]);\n\n  return NavigationEnd;\n}(RouterEvent);\n/**\n * \\@whatItDoes Represents an event triggered when a navigation is canceled.\n *\n * \\@stable\n */\n\n\nvar NavigationCancel = /*#__PURE__*/function (_RouterEvent3) {\n  _inherits(NavigationCancel, _RouterEvent3);\n\n  var _super3 = _createSuper(NavigationCancel);\n\n  /**\n   * @param {?} id\n   * @param {?} url\n   * @param {?} reason\n   */\n  function NavigationCancel(\n  /** @docsNotRequired */\n\n  /** @docsNotRequired */\n  id,\n  /** @docsNotRequired */\n\n  /** @docsNotRequired */\n  url, reason) {\n    var _this2;\n\n    _classCallCheck(this, NavigationCancel);\n\n    _this2 = _super3.call(this, id, url);\n    _this2.reason = reason;\n    return _this2;\n  }\n  /**\n   * \\@docsNotRequired\n   * @return {?}\n   */\n\n\n  _createClass(NavigationCancel, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"NavigationCancel(id: \".concat(this.id, \", url: '\").concat(this.url, \"')\");\n    }\n  }]);\n\n  return NavigationCancel;\n}(RouterEvent);\n/**\n * \\@whatItDoes Represents an event triggered when a navigation fails due to an unexpected error.\n *\n * \\@stable\n */\n\n\nvar NavigationError = /*#__PURE__*/function (_RouterEvent4) {\n  _inherits(NavigationError, _RouterEvent4);\n\n  var _super4 = _createSuper(NavigationError);\n\n  /**\n   * @param {?} id\n   * @param {?} url\n   * @param {?} error\n   */\n  function NavigationError(\n  /** @docsNotRequired */\n\n  /** @docsNotRequired */\n  id,\n  /** @docsNotRequired */\n\n  /** @docsNotRequired */\n  url, error) {\n    var _this3;\n\n    _classCallCheck(this, NavigationError);\n\n    _this3 = _super4.call(this, id, url);\n    _this3.error = error;\n    return _this3;\n  }\n  /**\n   * \\@docsNotRequired\n   * @return {?}\n   */\n\n\n  _createClass(NavigationError, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"NavigationError(id: \".concat(this.id, \", url: '\").concat(this.url, \"', error: \").concat(this.error, \")\");\n    }\n  }]);\n\n  return NavigationError;\n}(RouterEvent);\n/**\n * \\@whatItDoes Represents an event triggered when routes are recognized.\n *\n * \\@stable\n */\n\n\nvar RoutesRecognized = /*#__PURE__*/function (_RouterEvent5) {\n  _inherits(RoutesRecognized, _RouterEvent5);\n\n  var _super5 = _createSuper(RoutesRecognized);\n\n  /**\n   * @param {?} id\n   * @param {?} url\n   * @param {?} urlAfterRedirects\n   * @param {?} state\n   */\n  function RoutesRecognized(\n  /** @docsNotRequired */\n\n  /** @docsNotRequired */\n  id,\n  /** @docsNotRequired */\n\n  /** @docsNotRequired */\n  url, urlAfterRedirects, state) {\n    var _this4;\n\n    _classCallCheck(this, RoutesRecognized);\n\n    _this4 = _super5.call(this, id, url);\n    _this4.urlAfterRedirects = urlAfterRedirects;\n    _this4.state = state;\n    return _this4;\n  }\n  /**\n   * \\@docsNotRequired\n   * @return {?}\n   */\n\n\n  _createClass(RoutesRecognized, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"RoutesRecognized(id: \".concat(this.id, \", url: '\").concat(this.url, \"', urlAfterRedirects: '\").concat(this.urlAfterRedirects, \"', state: \").concat(this.state, \")\");\n    }\n  }]);\n\n  return RoutesRecognized;\n}(RouterEvent);\n/**\n * \\@whatItDoes Represents the start of the Guard phase of routing.\n *\n * \\@experimental\n */\n\n\nvar GuardsCheckStart = /*#__PURE__*/function (_RouterEvent6) {\n  _inherits(GuardsCheckStart, _RouterEvent6);\n\n  var _super6 = _createSuper(GuardsCheckStart);\n\n  /**\n   * @param {?} id\n   * @param {?} url\n   * @param {?} urlAfterRedirects\n   * @param {?} state\n   */\n  function GuardsCheckStart(\n  /** @docsNotRequired */\n\n  /** @docsNotRequired */\n  id,\n  /** @docsNotRequired */\n\n  /** @docsNotRequired */\n  url, urlAfterRedirects, state) {\n    var _this5;\n\n    _classCallCheck(this, GuardsCheckStart);\n\n    _this5 = _super6.call(this, id, url);\n    _this5.urlAfterRedirects = urlAfterRedirects;\n    _this5.state = state;\n    return _this5;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(GuardsCheckStart, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"GuardsCheckStart(id: \".concat(this.id, \", url: '\").concat(this.url, \"', urlAfterRedirects: '\").concat(this.urlAfterRedirects, \"', state: \").concat(this.state, \")\");\n    }\n  }]);\n\n  return GuardsCheckStart;\n}(RouterEvent);\n/**\n * \\@whatItDoes Represents the end of the Guard phase of routing.\n *\n * \\@experimental\n */\n\n\nvar GuardsCheckEnd = /*#__PURE__*/function (_RouterEvent7) {\n  _inherits(GuardsCheckEnd, _RouterEvent7);\n\n  var _super7 = _createSuper(GuardsCheckEnd);\n\n  /**\n   * @param {?} id\n   * @param {?} url\n   * @param {?} urlAfterRedirects\n   * @param {?} state\n   * @param {?} shouldActivate\n   */\n  function GuardsCheckEnd(\n  /** @docsNotRequired */\n\n  /** @docsNotRequired */\n  id,\n  /** @docsNotRequired */\n\n  /** @docsNotRequired */\n  url, urlAfterRedirects, state, shouldActivate) {\n    var _this6;\n\n    _classCallCheck(this, GuardsCheckEnd);\n\n    _this6 = _super7.call(this, id, url);\n    _this6.urlAfterRedirects = urlAfterRedirects;\n    _this6.state = state;\n    _this6.shouldActivate = shouldActivate;\n    return _this6;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(GuardsCheckEnd, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"GuardsCheckEnd(id: \".concat(this.id, \", url: '\").concat(this.url, \"', urlAfterRedirects: '\").concat(this.urlAfterRedirects, \"', state: \").concat(this.state, \", shouldActivate: \").concat(this.shouldActivate, \")\");\n    }\n  }]);\n\n  return GuardsCheckEnd;\n}(RouterEvent);\n/**\n * \\@whatItDoes Represents the start of the Resolve phase of routing. The timing of this\n * event may change, thus it's experimental. In the current iteration it will run\n * in the \"resolve\" phase whether there's things to resolve or not. In the future this\n * behavior may change to only run when there are things to be resolved.\n *\n * \\@experimental\n */\n\n\nvar ResolveStart = /*#__PURE__*/function (_RouterEvent8) {\n  _inherits(ResolveStart, _RouterEvent8);\n\n  var _super8 = _createSuper(ResolveStart);\n\n  /**\n   * @param {?} id\n   * @param {?} url\n   * @param {?} urlAfterRedirects\n   * @param {?} state\n   */\n  function ResolveStart(\n  /** @docsNotRequired */\n\n  /** @docsNotRequired */\n  id,\n  /** @docsNotRequired */\n\n  /** @docsNotRequired */\n  url, urlAfterRedirects, state) {\n    var _this7;\n\n    _classCallCheck(this, ResolveStart);\n\n    _this7 = _super8.call(this, id, url);\n    _this7.urlAfterRedirects = urlAfterRedirects;\n    _this7.state = state;\n    return _this7;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(ResolveStart, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"ResolveStart(id: \".concat(this.id, \", url: '\").concat(this.url, \"', urlAfterRedirects: '\").concat(this.urlAfterRedirects, \"', state: \").concat(this.state, \")\");\n    }\n  }]);\n\n  return ResolveStart;\n}(RouterEvent);\n/**\n * \\@whatItDoes Represents the end of the Resolve phase of routing. See note on\n * {\\@link ResolveStart} for use of this experimental API.\n *\n * \\@experimental\n */\n\n\nvar ResolveEnd = /*#__PURE__*/function (_RouterEvent9) {\n  _inherits(ResolveEnd, _RouterEvent9);\n\n  var _super9 = _createSuper(ResolveEnd);\n\n  /**\n   * @param {?} id\n   * @param {?} url\n   * @param {?} urlAfterRedirects\n   * @param {?} state\n   */\n  function ResolveEnd(\n  /** @docsNotRequired */\n\n  /** @docsNotRequired */\n  id,\n  /** @docsNotRequired */\n\n  /** @docsNotRequired */\n  url, urlAfterRedirects, state) {\n    var _this8;\n\n    _classCallCheck(this, ResolveEnd);\n\n    _this8 = _super9.call(this, id, url);\n    _this8.urlAfterRedirects = urlAfterRedirects;\n    _this8.state = state;\n    return _this8;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(ResolveEnd, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"ResolveEnd(id: \".concat(this.id, \", url: '\").concat(this.url, \"', urlAfterRedirects: '\").concat(this.urlAfterRedirects, \"', state: \").concat(this.state, \")\");\n    }\n  }]);\n\n  return ResolveEnd;\n}(RouterEvent);\n/**\n * \\@whatItDoes Represents an event triggered before lazy loading a route config.\n *\n * \\@experimental\n */\n\n\nvar RouteConfigLoadStart = /*#__PURE__*/function () {\n  /**\n   * @param {?} route\n   */\n  function RouteConfigLoadStart(route) {\n    _classCallCheck(this, RouteConfigLoadStart);\n\n    this.route = route;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(RouteConfigLoadStart, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"RouteConfigLoadStart(path: \".concat(this.route.path, \")\");\n    }\n  }]);\n\n  return RouteConfigLoadStart;\n}();\n/**\n * \\@whatItDoes Represents an event triggered when a route has been lazy loaded.\n *\n * \\@experimental\n */\n\n\nvar RouteConfigLoadEnd = /*#__PURE__*/function () {\n  /**\n   * @param {?} route\n   */\n  function RouteConfigLoadEnd(route) {\n    _classCallCheck(this, RouteConfigLoadEnd);\n\n    this.route = route;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(RouteConfigLoadEnd, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"RouteConfigLoadEnd(path: \".concat(this.route.path, \")\");\n    }\n  }]);\n\n  return RouteConfigLoadEnd;\n}();\n/**\n * \\@whatItDoes Represents the start of end of the Resolve phase of routing. See note on\n * {\\@link ChildActivationEnd} for use of this experimental API.\n *\n * \\@experimental\n */\n\n\nvar ChildActivationStart = /*#__PURE__*/function () {\n  /**\n   * @param {?} snapshot\n   */\n  function ChildActivationStart(snapshot) {\n    _classCallCheck(this, ChildActivationStart);\n\n    this.snapshot = snapshot;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(ChildActivationStart, [{\n    key: \"toString\",\n    value: function toString() {\n      var\n      /** @type {?} */\n      path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';\n      return \"ChildActivationStart(path: '\".concat(path, \"')\");\n    }\n  }]);\n\n  return ChildActivationStart;\n}();\n/**\n * \\@whatItDoes Represents the start of end of the Resolve phase of routing. See note on\n * {\\@link ChildActivationStart} for use of this experimental API.\n *\n * \\@experimental\n */\n\n\nvar ChildActivationEnd = /*#__PURE__*/function () {\n  /**\n   * @param {?} snapshot\n   */\n  function ChildActivationEnd(snapshot) {\n    _classCallCheck(this, ChildActivationEnd);\n\n    this.snapshot = snapshot;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(ChildActivationEnd, [{\n    key: \"toString\",\n    value: function toString() {\n      var\n      /** @type {?} */\n      path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';\n      return \"ChildActivationEnd(path: '\".concat(path, \"')\");\n    }\n  }]);\n\n  return ChildActivationEnd;\n}();\n/**\n * \\@whatItDoes Represents the start of end of the Resolve phase of routing. See note on\n * {\\@link ActivationEnd} for use of this experimental API.\n *\n * \\@experimental\n */\n\n\nvar ActivationStart = /*#__PURE__*/function () {\n  /**\n   * @param {?} snapshot\n   */\n  function ActivationStart(snapshot) {\n    _classCallCheck(this, ActivationStart);\n\n    this.snapshot = snapshot;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(ActivationStart, [{\n    key: \"toString\",\n    value: function toString() {\n      var\n      /** @type {?} */\n      path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';\n      return \"ActivationStart(path: '\".concat(path, \"')\");\n    }\n  }]);\n\n  return ActivationStart;\n}();\n/**\n * \\@whatItDoes Represents the start of end of the Resolve phase of routing. See note on\n * {\\@link ActivationStart} for use of this experimental API.\n *\n * \\@experimental\n */\n\n\nvar ActivationEnd = /*#__PURE__*/function () {\n  /**\n   * @param {?} snapshot\n   */\n  function ActivationEnd(snapshot) {\n    _classCallCheck(this, ActivationEnd);\n\n    this.snapshot = snapshot;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(ActivationEnd, [{\n    key: \"toString\",\n    value: function toString() {\n      var\n      /** @type {?} */\n      path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';\n      return \"ActivationEnd(path: '\".concat(path, \"')\");\n    }\n  }]);\n\n  return ActivationEnd;\n}();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * \\@whatItDoes Name of the primary outlet.\n *\n * \\@stable\n */\n\n\nvar PRIMARY_OUTLET = 'primary';\n/**\n * Matrix and Query parameters.\n *\n * `ParamMap` makes it easier to work with parameters as they could have either a single value or\n * multiple value. Because this should be known by the user, calling `get` or `getAll` returns the\n * correct type (either `string` or `string[]`).\n *\n * The API is inspired by the URLSearchParams interface.\n * see https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams\n *\n * \\@stable\n * @record\n */\n\nvar ParamsAsMap = /*#__PURE__*/function () {\n  /**\n   * @param {?} params\n   */\n  function ParamsAsMap(params) {\n    _classCallCheck(this, ParamsAsMap);\n\n    this.params = params || {};\n  }\n  /**\n   * @param {?} name\n   * @return {?}\n   */\n\n\n  _createClass(ParamsAsMap, [{\n    key: \"has\",\n    value: function has(name) {\n      return this.params.hasOwnProperty(name);\n    }\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(name) {\n      if (this.has(name)) {\n        var\n        /** @type {?} */\n        v = this.params[name];\n        return Array.isArray(v) ? v[0] : v;\n      }\n\n      return null;\n    }\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n\n  }, {\n    key: \"getAll\",\n    value: function getAll(name) {\n      if (this.has(name)) {\n        var\n        /** @type {?} */\n        v = this.params[name];\n        return Array.isArray(v) ? v : [v];\n      }\n\n      return [];\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"keys\",\n    get: function get() {\n      return Object.keys(this.params);\n    }\n  }]);\n\n  return ParamsAsMap;\n}();\n/**\n * Convert a {\\@link Params} instance to a {\\@link ParamMap}.\n *\n * \\@stable\n * @param {?} params\n * @return {?}\n */\n\n\nfunction convertToParamMap(params) {\n  return new ParamsAsMap(params);\n}\n\nvar NAVIGATION_CANCELING_ERROR = 'ngNavigationCancelingError';\n/**\n * @param {?} message\n * @return {?}\n */\n\nfunction navigationCancelingError(message) {\n  var\n  /** @type {?} */\n  error = Error('NavigationCancelingError: ' + message);\n\n  /** @type {?} */\n  error[NAVIGATION_CANCELING_ERROR] = true;\n  return error;\n}\n/**\n * @param {?} error\n * @return {?}\n */\n\n\nfunction isNavigationCancelingError(error) {\n  return error &&\n  /** @type {?} */\n  error[NAVIGATION_CANCELING_ERROR];\n}\n/**\n * @param {?} segments\n * @param {?} segmentGroup\n * @param {?} route\n * @return {?}\n */\n\n\nfunction defaultUrlMatcher(segments, segmentGroup, route) {\n  var\n  /** @type {?} */\n  parts =\n  /** @type {?} */\n  route.path.split('/');\n\n  if (parts.length > segments.length) {\n    // The actual URL is shorter than the config, no match\n    return null;\n  }\n\n  if (route.pathMatch === 'full' && (segmentGroup.hasChildren() || parts.length < segments.length)) {\n    // The config is longer than the actual URL but we are looking for a full match, return null\n    return null;\n  }\n\n  var\n  /** @type {?} */\n  posParams = {}; // Check each config part against the actual URL\n\n  for (var\n  /** @type {?} */\n  index = 0; index < parts.length; index++) {\n    var\n    /** @type {?} */\n    part = parts[index];\n    var\n    /** @type {?} */\n    segment = segments[index];\n    var\n    /** @type {?} */\n    isParameter = part.startsWith(':');\n\n    if (isParameter) {\n      posParams[part.substring(1)] = segment;\n    } else if (part !== segment.path) {\n      // The actual URL part does not match the config, no match\n      return null;\n    }\n  }\n\n  return {\n    consumed: segments.slice(0, parts.length),\n    posParams: posParams\n  };\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * See {\\@link Routes} for more details.\n * \\@stable\n * @record\n */\n\n\nvar LoadedRouterConfig = /*#__PURE__*/_createClass(\n/**\n * @param {?} routes\n * @param {?} module\n */\nfunction LoadedRouterConfig(routes, module) {\n  _classCallCheck(this, LoadedRouterConfig);\n\n  this.routes = routes;\n  this.module = module;\n});\n/**\n * @param {?} config\n * @param {?=} parentPath\n * @return {?}\n */\n\n\nfunction validateConfig(config) {\n  var parentPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n\n  // forEach doesn't iterate undefined values\n  for (var\n  /** @type {?} */\n  i = 0; i < config.length; i++) {\n    var\n    /** @type {?} */\n    route = config[i];\n    var\n    /** @type {?} */\n    fullPath = getFullPath(parentPath, route);\n    validateNode(route, fullPath);\n  }\n}\n/**\n * @param {?} route\n * @param {?} fullPath\n * @return {?}\n */\n\n\nfunction validateNode(route, fullPath) {\n  if (!route) {\n    throw new Error(\"\\n      Invalid configuration of route '\".concat(fullPath, \"': Encountered undefined route.\\n      The reason might be an extra comma.\\n\\n      Example:\\n      const routes: Routes = [\\n        { path: '', redirectTo: '/dashboard', pathMatch: 'full' },\\n        { path: 'dashboard',  component: DashboardComponent },, << two commas\\n        { path: 'detail/:id', component: HeroDetailComponent }\\n      ];\\n    \"));\n  }\n\n  if (Array.isArray(route)) {\n    throw new Error(\"Invalid configuration of route '\".concat(fullPath, \"': Array cannot be specified\"));\n  }\n\n  if (!route.component && route.outlet && route.outlet !== PRIMARY_OUTLET) {\n    throw new Error(\"Invalid configuration of route '\".concat(fullPath, \"': a componentless route cannot have a named outlet set\"));\n  }\n\n  if (route.redirectTo && route.children) {\n    throw new Error(\"Invalid configuration of route '\".concat(fullPath, \"': redirectTo and children cannot be used together\"));\n  }\n\n  if (route.redirectTo && route.loadChildren) {\n    throw new Error(\"Invalid configuration of route '\".concat(fullPath, \"': redirectTo and loadChildren cannot be used together\"));\n  }\n\n  if (route.children && route.loadChildren) {\n    throw new Error(\"Invalid configuration of route '\".concat(fullPath, \"': children and loadChildren cannot be used together\"));\n  }\n\n  if (route.redirectTo && route.component) {\n    throw new Error(\"Invalid configuration of route '\".concat(fullPath, \"': redirectTo and component cannot be used together\"));\n  }\n\n  if (route.path && route.matcher) {\n    throw new Error(\"Invalid configuration of route '\".concat(fullPath, \"': path and matcher cannot be used together\"));\n  }\n\n  if (route.redirectTo === void 0 && !route.component && !route.children && !route.loadChildren) {\n    throw new Error(\"Invalid configuration of route '\".concat(fullPath, \"'. One of the following must be provided: component, redirectTo, children or loadChildren\"));\n  }\n\n  if (route.path === void 0 && route.matcher === void 0) {\n    throw new Error(\"Invalid configuration of route '\".concat(fullPath, \"': routes must have either a path or a matcher specified\"));\n  }\n\n  if (typeof route.path === 'string' && route.path.charAt(0) === '/') {\n    throw new Error(\"Invalid configuration of route '\".concat(fullPath, \"': path cannot start with a slash\"));\n  }\n\n  if (route.path === '' && route.redirectTo !== void 0 && route.pathMatch === void 0) {\n    var\n    /** @type {?} */\n    exp = \"The default value of 'pathMatch' is 'prefix', but often the intent is to use 'full'.\";\n    throw new Error(\"Invalid configuration of route '{path: \\\"\".concat(fullPath, \"\\\", redirectTo: \\\"\").concat(route.redirectTo, \"\\\"}': please provide 'pathMatch'. \").concat(exp));\n  }\n\n  if (route.pathMatch !== void 0 && route.pathMatch !== 'full' && route.pathMatch !== 'prefix') {\n    throw new Error(\"Invalid configuration of route '\".concat(fullPath, \"': pathMatch can only be set to 'prefix' or 'full'\"));\n  }\n\n  if (route.children) {\n    validateConfig(route.children, fullPath);\n  }\n}\n/**\n * @param {?} parentPath\n * @param {?} currentRoute\n * @return {?}\n */\n\n\nfunction getFullPath(parentPath, currentRoute) {\n  if (!currentRoute) {\n    return parentPath;\n  }\n\n  if (!parentPath && !currentRoute.path) {\n    return '';\n  } else if (parentPath && !currentRoute.path) {\n    return \"\".concat(parentPath, \"/\");\n  } else if (!parentPath && currentRoute.path) {\n    return currentRoute.path;\n  } else {\n    return \"\".concat(parentPath, \"/\").concat(currentRoute.path);\n  }\n}\n/**\n * @param {?} r\n * @return {?}\n */\n\n\nfunction copyConfig(r) {\n  var\n  /** @type {?} */\n  children = r.children && r.children.map(copyConfig);\n  return children ? Object.assign({}, r, {\n    children: children\n  }) : Object.assign({}, r);\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @param {?} a\n * @param {?} b\n * @return {?}\n */\n\n\nfunction shallowEqualArrays(a, b) {\n  if (a.length !== b.length) return false;\n\n  for (var\n  /** @type {?} */\n  i = 0; i < a.length; ++i) {\n    if (!shallowEqual(a[i], b[i])) return false;\n  }\n\n  return true;\n}\n/**\n * @param {?} a\n * @param {?} b\n * @return {?}\n */\n\n\nfunction shallowEqual(a, b) {\n  var\n  /** @type {?} */\n  k1 = Object.keys(a);\n  var\n  /** @type {?} */\n  k2 = Object.keys(b);\n\n  if (k1.length != k2.length) {\n    return false;\n  }\n\n  var\n  /** @type {?} */\n  key;\n\n  for (var\n  /** @type {?} */\n  i = 0; i < k1.length; i++) {\n    key = k1[i];\n\n    if (a[key] !== b[key]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * Flattens single-level nested arrays.\n * @template T\n * @param {?} arr\n * @return {?}\n */\n\n\nfunction flatten(arr) {\n  return Array.prototype.concat.apply([], arr);\n}\n/**\n * Return the last element of an array.\n * @template T\n * @param {?} a\n * @return {?}\n */\n\n\nfunction last$1(a) {\n  return a.length > 0 ? a[a.length - 1] : null;\n}\n/**\n * Verifys all booleans in an array are `true`.\n * @param {?} bools\n * @return {?}\n */\n\n/**\n * @template K, V\n * @param {?} map\n * @param {?} callback\n * @return {?}\n */\n\n\nfunction forEach(map$$1, callback) {\n  for (var\n  /** @type {?} */\n  prop in map$$1) {\n    if (map$$1.hasOwnProperty(prop)) {\n      callback(map$$1[prop], prop);\n    }\n  }\n}\n/**\n * @template A, B\n * @param {?} obj\n * @param {?} fn\n * @return {?}\n */\n\n\nfunction waitForMap(obj, fn) {\n  if (Object.keys(obj).length === 0) {\n    return of({});\n  }\n\n  var\n  /** @type {?} */\n  waitHead = [];\n  var\n  /** @type {?} */\n  waitTail = [];\n  var\n  /** @type {?} */\n  res = {};\n  forEach(obj, function (a, k) {\n    var\n    /** @type {?} */\n    mapped = map.call(fn(k, a), function (r) {\n      return res[k] = r;\n    });\n\n    if (k === PRIMARY_OUTLET) {\n      waitHead.push(mapped);\n    } else {\n      waitTail.push(mapped);\n    }\n  });\n  var\n  /** @type {?} */\n  concat$ = concatAll.call(of.apply(void 0, waitHead.concat(waitTail)));\n  var\n  /** @type {?} */\n  last$ = last.call(concat$);\n  return map.call(last$, function () {\n    return res;\n  });\n}\n/**\n * ANDs Observables by merging all input observables, reducing to an Observable verifying all\n * input Observables return `true`.\n * @param {?} observables\n * @return {?}\n */\n\n\nfunction andObservables(observables) {\n  var\n  /** @type {?} */\n  merged$ = mergeAll.call(observables);\n  return every.call(merged$, function (result) {\n    return result === true;\n  });\n}\n/**\n * @template T\n * @param {?} value\n * @return {?}\n */\n\n\nfunction wrapIntoObservable(value) {\n  if (ɵisObservable(value)) {\n    return value;\n  }\n\n  if (ɵisPromise(value)) {\n    // Use `Promise.resolve()` to wrap promise-like instances.\n    // Required ie when a Resolver returns a AngularJS `$q` promise to correctly trigger the\n    // change detection.\n    return fromPromise(Promise.resolve(value));\n  }\n\n  return of(\n  /** @type {?} */\n  value);\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @return {?}\n */\n\n\nfunction createEmptyUrlTree() {\n  return new UrlTree(new UrlSegmentGroup([], {}), {}, null);\n}\n/**\n * @param {?} container\n * @param {?} containee\n * @param {?} exact\n * @return {?}\n */\n\n\nfunction containsTree(container, containee, exact) {\n  if (exact) {\n    return equalQueryParams(container.queryParams, containee.queryParams) && equalSegmentGroups(container.root, containee.root);\n  }\n\n  return containsQueryParams(container.queryParams, containee.queryParams) && containsSegmentGroup(container.root, containee.root);\n}\n/**\n * @param {?} container\n * @param {?} containee\n * @return {?}\n */\n\n\nfunction equalQueryParams(container, containee) {\n  return shallowEqual(container, containee);\n}\n/**\n * @param {?} container\n * @param {?} containee\n * @return {?}\n */\n\n\nfunction equalSegmentGroups(container, containee) {\n  if (!equalPath(container.segments, containee.segments)) return false;\n  if (container.numberOfChildren !== containee.numberOfChildren) return false;\n\n  for (var\n  /** @type {?} */\n  c in containee.children) {\n    if (!container.children[c]) return false;\n    if (!equalSegmentGroups(container.children[c], containee.children[c])) return false;\n  }\n\n  return true;\n}\n/**\n * @param {?} container\n * @param {?} containee\n * @return {?}\n */\n\n\nfunction containsQueryParams(container, containee) {\n  return Object.keys(containee).length <= Object.keys(container).length && Object.keys(containee).every(function (key) {\n    return containee[key] === container[key];\n  });\n}\n/**\n * @param {?} container\n * @param {?} containee\n * @return {?}\n */\n\n\nfunction containsSegmentGroup(container, containee) {\n  return containsSegmentGroupHelper(container, containee, containee.segments);\n}\n/**\n * @param {?} container\n * @param {?} containee\n * @param {?} containeePaths\n * @return {?}\n */\n\n\nfunction containsSegmentGroupHelper(container, containee, containeePaths) {\n  if (container.segments.length > containeePaths.length) {\n    var\n    /** @type {?} */\n    current = container.segments.slice(0, containeePaths.length);\n    if (!equalPath(current, containeePaths)) return false;\n    if (containee.hasChildren()) return false;\n    return true;\n  } else if (container.segments.length === containeePaths.length) {\n    if (!equalPath(container.segments, containeePaths)) return false;\n\n    for (var\n    /** @type {?} */\n    c in containee.children) {\n      if (!container.children[c]) return false;\n      if (!containsSegmentGroup(container.children[c], containee.children[c])) return false;\n    }\n\n    return true;\n  } else {\n    var\n    /** @type {?} */\n    _current = containeePaths.slice(0, container.segments.length);\n\n    var\n    /** @type {?} */\n    next = containeePaths.slice(container.segments.length);\n    if (!equalPath(container.segments, _current)) return false;\n    if (!container.children[PRIMARY_OUTLET]) return false;\n    return containsSegmentGroupHelper(container.children[PRIMARY_OUTLET], containee, next);\n  }\n}\n/**\n * \\@whatItDoes Represents the parsed URL.\n *\n * \\@howToUse\n *\n * ```\n * \\@Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const tree: UrlTree =\n *       router.parseUrl('/team/33/(user/victor//support:help)?debug=true#fragment');\n *     const f = tree.fragment; // return 'fragment'\n *     const q = tree.queryParams; // returns {debug: 'true'}\n *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];\n *     const s: UrlSegment[] = g.segments; // returns 2 segments 'team' and '33'\n *     g.children[PRIMARY_OUTLET].segments; // returns 2 segments 'user' and 'victor'\n *     g.children['support'].segments; // return 1 segment 'help'\n *   }\n * }\n * ```\n *\n * \\@description\n *\n * Since a router state is a tree, and the URL is nothing but a serialized state, the URL is a\n * serialized tree.\n * UrlTree is a data structure that provides a lot of affordances in dealing with URLs\n *\n * \\@stable\n */\n\n\nvar UrlTree = /*#__PURE__*/function () {\n  /**\n   * \\@internal\n   * @param {?} root\n   * @param {?} queryParams\n   * @param {?} fragment\n   */\n  function UrlTree(root, queryParams, fragment) {\n    _classCallCheck(this, UrlTree);\n\n    this.root = root;\n    this.queryParams = queryParams;\n    this.fragment = fragment;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(UrlTree, [{\n    key: \"queryParamMap\",\n    get: function get() {\n      if (!this._queryParamMap) {\n        this._queryParamMap = convertToParamMap(this.queryParams);\n      }\n\n      return this._queryParamMap;\n    }\n    /**\n     * \\@docsNotRequired\n     * @return {?}\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return DEFAULT_SERIALIZER.serialize(this);\n    }\n  }]);\n\n  return UrlTree;\n}();\n/**\n * \\@whatItDoes Represents the parsed URL segment group.\n *\n * See {\\@link UrlTree} for more information.\n *\n * \\@stable\n */\n\n\nvar UrlSegmentGroup = /*#__PURE__*/function () {\n  /**\n   * @param {?} segments\n   * @param {?} children\n   */\n  function UrlSegmentGroup(segments, children) {\n    var _this9 = this;\n\n    _classCallCheck(this, UrlSegmentGroup);\n\n    this.segments = segments;\n    this.children = children;\n    /**\n     * The parent node in the url tree\n     */\n\n    this.parent = null;\n    forEach(children, function (v, k) {\n      return v.parent = _this9;\n    });\n  }\n  /**\n   * Whether the segment has child segments\n   * @return {?}\n   */\n\n\n  _createClass(UrlSegmentGroup, [{\n    key: \"hasChildren\",\n    value: function hasChildren() {\n      return this.numberOfChildren > 0;\n    }\n    /**\n     * Number of child segments\n     * @return {?}\n     */\n\n  }, {\n    key: \"numberOfChildren\",\n    get: function get() {\n      return Object.keys(this.children).length;\n    }\n    /**\n     * \\@docsNotRequired\n     * @return {?}\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return serializePaths(this);\n    }\n  }]);\n\n  return UrlSegmentGroup;\n}();\n/**\n * \\@whatItDoes Represents a single URL segment.\n *\n * \\@howToUse\n *\n * ```\n * \\@Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const tree: UrlTree = router.parseUrl('/team;id=33');\n *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];\n *     const s: UrlSegment[] = g.segments;\n *     s[0].path; // returns 'team'\n *     s[0].parameters; // returns {id: 33}\n *   }\n * }\n * ```\n *\n * \\@description\n *\n * A UrlSegment is a part of a URL between the two slashes. It contains a path and the matrix\n * parameters associated with the segment.\n *\n * \\@stable\n */\n\n\nvar UrlSegment = /*#__PURE__*/function () {\n  /**\n   * @param {?} path\n   * @param {?} parameters\n   */\n  function UrlSegment(path, parameters) {\n    _classCallCheck(this, UrlSegment);\n\n    this.path = path;\n    this.parameters = parameters;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(UrlSegment, [{\n    key: \"parameterMap\",\n    get: function get() {\n      if (!this._parameterMap) {\n        this._parameterMap = convertToParamMap(this.parameters);\n      }\n\n      return this._parameterMap;\n    }\n    /**\n     * \\@docsNotRequired\n     * @return {?}\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return serializePath(this);\n    }\n  }]);\n\n  return UrlSegment;\n}();\n/**\n * @param {?} as\n * @param {?} bs\n * @return {?}\n */\n\n\nfunction equalSegments(as, bs) {\n  return equalPath(as, bs) && as.every(function (a, i) {\n    return shallowEqual(a.parameters, bs[i].parameters);\n  });\n}\n/**\n * @param {?} as\n * @param {?} bs\n * @return {?}\n */\n\n\nfunction equalPath(as, bs) {\n  if (as.length !== bs.length) return false;\n  return as.every(function (a, i) {\n    return a.path === bs[i].path;\n  });\n}\n/**\n * @template T\n * @param {?} segment\n * @param {?} fn\n * @return {?}\n */\n\n\nfunction mapChildrenIntoArray(segment, fn) {\n  var\n  /** @type {?} */\n  res = [];\n  forEach(segment.children, function (child, childOutlet) {\n    if (childOutlet === PRIMARY_OUTLET) {\n      res = res.concat(fn(child, childOutlet));\n    }\n  });\n  forEach(segment.children, function (child, childOutlet) {\n    if (childOutlet !== PRIMARY_OUTLET) {\n      res = res.concat(fn(child, childOutlet));\n    }\n  });\n  return res;\n}\n/**\n * \\@whatItDoes Serializes and deserializes a URL string into a URL tree.\n *\n * \\@description The url serialization strategy is customizable. You can\n * make all URLs case insensitive by providing a custom UrlSerializer.\n *\n * See {\\@link DefaultUrlSerializer} for an example of a URL serializer.\n *\n * \\@stable\n * @abstract\n */\n\n\nvar UrlSerializer = /*#__PURE__*/_createClass(function UrlSerializer() {\n  _classCallCheck(this, UrlSerializer);\n});\n/**\n * \\@whatItDoes A default implementation of the {\\@link UrlSerializer}.\n *\n * \\@description\n *\n * Example URLs:\n *\n * ```\n * /inbox/33(popup:compose)\n * /inbox/33;open=true/messages/44\n * ```\n *\n * DefaultUrlSerializer uses parentheses to serialize secondary segments (e.g., popup:compose), the\n * colon syntax to specify the outlet, and the ';parameter=value' syntax (e.g., open=true) to\n * specify route specific parameters.\n *\n * \\@stable\n */\n\n\nvar DefaultUrlSerializer = /*#__PURE__*/function () {\n  function DefaultUrlSerializer() {\n    _classCallCheck(this, DefaultUrlSerializer);\n  }\n\n  _createClass(DefaultUrlSerializer, [{\n    key: \"parse\",\n    value:\n    /**\n     * Parses a url into a {\\@link UrlTree}\n     * @param {?} url\n     * @return {?}\n     */\n    function parse(url) {\n      var\n      /** @type {?} */\n      p = new UrlParser(url);\n      return new UrlTree(p.parseRootSegment(), p.parseQueryParams(), p.parseFragment());\n    }\n    /**\n     * Converts a {\\@link UrlTree} into a url\n     * @param {?} tree\n     * @return {?}\n     */\n\n  }, {\n    key: \"serialize\",\n    value: function serialize(tree) {\n      var\n      /** @type {?} */\n      segment = \"/\".concat(serializeSegment(tree.root, true));\n      var\n      /** @type {?} */\n      query = serializeQueryParams(tree.queryParams);\n      var\n      /** @type {?} */\n      fragment = typeof tree.fragment === \"string\" ? \"#\".concat(encodeUriFragment(\n      /** @type {?} */\n      tree.fragment)) : '';\n      return \"\".concat(segment).concat(query).concat(fragment);\n    }\n  }]);\n\n  return DefaultUrlSerializer;\n}();\n\nvar DEFAULT_SERIALIZER = /*#__PURE__*/new DefaultUrlSerializer();\n/**\n * @param {?} segment\n * @return {?}\n */\n\nfunction serializePaths(segment) {\n  return segment.segments.map(function (p) {\n    return serializePath(p);\n  }).join('/');\n}\n/**\n * @param {?} segment\n * @param {?} root\n * @return {?}\n */\n\n\nfunction serializeSegment(segment, root) {\n  if (!segment.hasChildren()) {\n    return serializePaths(segment);\n  }\n\n  if (root) {\n    var\n    /** @type {?} */\n    primary = segment.children[PRIMARY_OUTLET] ? serializeSegment(segment.children[PRIMARY_OUTLET], false) : '';\n    var\n    /** @type {?} */\n    children = [];\n    forEach(segment.children, function (v, k) {\n      if (k !== PRIMARY_OUTLET) {\n        children.push(\"\".concat(k, \":\").concat(serializeSegment(v, false)));\n      }\n    });\n    return children.length > 0 ? \"\".concat(primary, \"(\").concat(children.join('//'), \")\") : primary;\n  } else {\n    var\n    /** @type {?} */\n    _children = mapChildrenIntoArray(segment, function (v, k) {\n      if (k === PRIMARY_OUTLET) {\n        return [serializeSegment(segment.children[PRIMARY_OUTLET], false)];\n      }\n\n      return [\"\".concat(k, \":\").concat(serializeSegment(v, false))];\n    });\n\n    return \"\".concat(serializePaths(segment), \"/(\").concat(_children.join('//'), \")\");\n  }\n}\n/**\n * Encodes a URI string with the default encoding. This function will only ever be called from\n * `encodeUriQuery` or `encodeUriSegment` as it's the base set of encodings to be used. We need\n * a custom encoding because encodeURIComponent is too aggressive and encodes stuff that doesn't\n * have to be encoded per https://url.spec.whatwg.org.\n * @param {?} s\n * @return {?}\n */\n\n\nfunction encodeUriString(s) {\n  return encodeURIComponent(s).replace(/%40/g, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',');\n}\n/**\n * This function should be used to encode both keys and values in a query string key/value. In\n * the following URL, you need to call encodeUriQuery on \"k\" and \"v\":\n *\n * http://www.site.org/html;mk=mv?k=v#f\n * @param {?} s\n * @return {?}\n */\n\n\nfunction encodeUriQuery(s) {\n  return encodeUriString(s).replace(/%3B/gi, ';');\n}\n/**\n * This function should be used to encode a URL fragment. In the following URL, you need to call\n * encodeUriFragment on \"f\":\n *\n * http://www.site.org/html;mk=mv?k=v#f\n * @param {?} s\n * @return {?}\n */\n\n\nfunction encodeUriFragment(s) {\n  return encodeURI(s);\n}\n/**\n * This function should be run on any URI segment as well as the key and value in a key/value\n * pair for matrix params. In the following URL, you need to call encodeUriSegment on \"html\",\n * \"mk\", and \"mv\":\n *\n * http://www.site.org/html;mk=mv?k=v#f\n * @param {?} s\n * @return {?}\n */\n\n\nfunction encodeUriSegment(s) {\n  return encodeUriString(s).replace(/\\(/g, '%28').replace(/\\)/g, '%29').replace(/%26/gi, '&');\n}\n/**\n * @param {?} s\n * @return {?}\n */\n\n\nfunction decode(s) {\n  return decodeURIComponent(s);\n}\n/**\n * @param {?} s\n * @return {?}\n */\n\n\nfunction decodeQuery(s) {\n  return decode(s.replace(/\\+/g, '%20'));\n}\n/**\n * @param {?} path\n * @return {?}\n */\n\n\nfunction serializePath(path) {\n  return \"\".concat(encodeUriSegment(path.path)).concat(serializeMatrixParams(path.parameters));\n}\n/**\n * @param {?} params\n * @return {?}\n */\n\n\nfunction serializeMatrixParams(params) {\n  return Object.keys(params).map(function (key) {\n    return \";\".concat(encodeUriSegment(key), \"=\").concat(encodeUriSegment(params[key]));\n  }).join('');\n}\n/**\n * @param {?} params\n * @return {?}\n */\n\n\nfunction serializeQueryParams(params) {\n  var\n  /** @type {?} */\n  strParams = Object.keys(params).map(function (name) {\n    var\n    /** @type {?} */\n    value = params[name];\n    return Array.isArray(value) ? value.map(function (v) {\n      return \"\".concat(encodeUriQuery(name), \"=\").concat(encodeUriQuery(v));\n    }).join('&') : \"\".concat(encodeUriQuery(name), \"=\").concat(encodeUriQuery(value));\n  });\n  return strParams.length ? \"?\".concat(strParams.join(\"&\")) : '';\n}\n\nvar SEGMENT_RE = /^[^\\/()?;=&#]+/;\n/**\n * @param {?} str\n * @return {?}\n */\n\nfunction matchSegments(str) {\n  var\n  /** @type {?} */\n  match = str.match(SEGMENT_RE);\n  return match ? match[0] : '';\n}\n\nvar QUERY_PARAM_RE = /^[^=?&#]+/;\n/**\n * @param {?} str\n * @return {?}\n */\n\nfunction matchQueryParams(str) {\n  var\n  /** @type {?} */\n  match = str.match(QUERY_PARAM_RE);\n  return match ? match[0] : '';\n}\n\nvar QUERY_PARAM_VALUE_RE = /^[^?&#]+/;\n/**\n * @param {?} str\n * @return {?}\n */\n\nfunction matchUrlQueryParamValue(str) {\n  var\n  /** @type {?} */\n  match = str.match(QUERY_PARAM_VALUE_RE);\n  return match ? match[0] : '';\n}\n\nvar UrlParser = /*#__PURE__*/function () {\n  /**\n   * @param {?} url\n   */\n  function UrlParser(url) {\n    _classCallCheck(this, UrlParser);\n\n    this.url = url;\n    this.remaining = url;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(UrlParser, [{\n    key: \"parseRootSegment\",\n    value: function parseRootSegment() {\n      this.consumeOptional('/');\n\n      if (this.remaining === '' || this.peekStartsWith('?') || this.peekStartsWith('#')) {\n        return new UrlSegmentGroup([], {});\n      } // The root segment group never has segments\n\n\n      return new UrlSegmentGroup([], this.parseChildren());\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"parseQueryParams\",\n    value: function parseQueryParams() {\n      var\n      /** @type {?} */\n      params = {};\n\n      if (this.consumeOptional('?')) {\n        do {\n          this.parseQueryParam(params);\n        } while (this.consumeOptional('&'));\n      }\n\n      return params;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"parseFragment\",\n    value: function parseFragment() {\n      return this.consumeOptional('#') ? decodeURIComponent(this.remaining) : null;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"parseChildren\",\n    value: function parseChildren() {\n      if (this.remaining === '') {\n        return {};\n      }\n\n      this.consumeOptional('/');\n      var\n      /** @type {?} */\n      segments = [];\n\n      if (!this.peekStartsWith('(')) {\n        segments.push(this.parseSegment());\n      }\n\n      while (this.peekStartsWith('/') && !this.peekStartsWith('//') && !this.peekStartsWith('/(')) {\n        this.capture('/');\n        segments.push(this.parseSegment());\n      }\n\n      var\n      /** @type {?} */\n      children = {};\n\n      if (this.peekStartsWith('/(')) {\n        this.capture('/');\n        children = this.parseParens(true);\n      }\n\n      var\n      /** @type {?} */\n      res = {};\n\n      if (this.peekStartsWith('(')) {\n        res = this.parseParens(false);\n      }\n\n      if (segments.length > 0 || Object.keys(children).length > 0) {\n        res[PRIMARY_OUTLET] = new UrlSegmentGroup(segments, children);\n      }\n\n      return res;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"parseSegment\",\n    value: function parseSegment() {\n      var\n      /** @type {?} */\n      path = matchSegments(this.remaining);\n\n      if (path === '' && this.peekStartsWith(';')) {\n        throw new Error(\"Empty path url segment cannot have parameters: '\".concat(this.remaining, \"'.\"));\n      }\n\n      this.capture(path);\n      return new UrlSegment(decode(path), this.parseMatrixParams());\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"parseMatrixParams\",\n    value: function parseMatrixParams() {\n      var\n      /** @type {?} */\n      params = {};\n\n      while (this.consumeOptional(';')) {\n        this.parseParam(params);\n      }\n\n      return params;\n    }\n    /**\n     * @param {?} params\n     * @return {?}\n     */\n\n  }, {\n    key: \"parseParam\",\n    value: function parseParam(params) {\n      var\n      /** @type {?} */\n      key = matchSegments(this.remaining);\n\n      if (!key) {\n        return;\n      }\n\n      this.capture(key);\n      var\n      /** @type {?} */\n      value = '';\n\n      if (this.consumeOptional('=')) {\n        var\n        /** @type {?} */\n        valueMatch = matchSegments(this.remaining);\n\n        if (valueMatch) {\n          value = valueMatch;\n          this.capture(value);\n        }\n      }\n\n      params[decode(key)] = decode(value);\n    }\n    /**\n     * @param {?} params\n     * @return {?}\n     */\n\n  }, {\n    key: \"parseQueryParam\",\n    value: function parseQueryParam(params) {\n      var\n      /** @type {?} */\n      key = matchQueryParams(this.remaining);\n\n      if (!key) {\n        return;\n      }\n\n      this.capture(key);\n      var\n      /** @type {?} */\n      value = '';\n\n      if (this.consumeOptional('=')) {\n        var\n        /** @type {?} */\n        valueMatch = matchUrlQueryParamValue(this.remaining);\n\n        if (valueMatch) {\n          value = valueMatch;\n          this.capture(value);\n        }\n      }\n\n      var\n      /** @type {?} */\n      decodedKey = decodeQuery(key);\n      var\n      /** @type {?} */\n      decodedVal = decodeQuery(value);\n\n      if (params.hasOwnProperty(decodedKey)) {\n        // Append to existing values\n        var\n        /** @type {?} */\n        currentVal = params[decodedKey];\n\n        if (!Array.isArray(currentVal)) {\n          currentVal = [currentVal];\n          params[decodedKey] = currentVal;\n        }\n\n        currentVal.push(decodedVal);\n      } else {\n        // Create a new value\n        params[decodedKey] = decodedVal;\n      }\n    }\n    /**\n     * @param {?} allowPrimary\n     * @return {?}\n     */\n\n  }, {\n    key: \"parseParens\",\n    value: function parseParens(allowPrimary) {\n      var\n      /** @type {?} */\n      segments = {};\n      this.capture('(');\n\n      while (!this.consumeOptional(')') && this.remaining.length > 0) {\n        var\n        /** @type {?} */\n        path = matchSegments(this.remaining);\n        var\n        /** @type {?} */\n        next = this.remaining[path.length]; // if is is not one of these characters, then the segment was unescaped\n        // or the group was not closed\n\n        if (next !== '/' && next !== ')' && next !== ';') {\n          throw new Error(\"Cannot parse url '\".concat(this.url, \"'\"));\n        }\n\n        var\n        /** @type {?} */\n        outletName =\n        /** @type {?} */\n        undefined;\n\n        if (path.indexOf(':') > -1) {\n          outletName = path.substr(0, path.indexOf(':'));\n          this.capture(outletName);\n          this.capture(':');\n        } else if (allowPrimary) {\n          outletName = PRIMARY_OUTLET;\n        }\n\n        var\n        /** @type {?} */\n        children = this.parseChildren();\n        segments[outletName] = Object.keys(children).length === 1 ? children[PRIMARY_OUTLET] : new UrlSegmentGroup([], children);\n        this.consumeOptional('//');\n      }\n\n      return segments;\n    }\n    /**\n     * @param {?} str\n     * @return {?}\n     */\n\n  }, {\n    key: \"peekStartsWith\",\n    value: function peekStartsWith(str) {\n      return this.remaining.startsWith(str);\n    }\n    /**\n     * @param {?} str\n     * @return {?}\n     */\n\n  }, {\n    key: \"consumeOptional\",\n    value: function consumeOptional(str) {\n      if (this.peekStartsWith(str)) {\n        this.remaining = this.remaining.substring(str.length);\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     * @param {?} str\n     * @return {?}\n     */\n\n  }, {\n    key: \"capture\",\n    value: function capture(str) {\n      if (!this.consumeOptional(str)) {\n        throw new Error(\"Expected \\\"\".concat(str, \"\\\".\"));\n      }\n    }\n  }]);\n\n  return UrlParser;\n}();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar NoMatch = /*#__PURE__*/_createClass(\n/**\n * @param {?=} segmentGroup\n */\nfunction NoMatch(segmentGroup) {\n  _classCallCheck(this, NoMatch);\n\n  this.segmentGroup = segmentGroup || null;\n});\n\nvar AbsoluteRedirect = /*#__PURE__*/_createClass(\n/**\n * @param {?} urlTree\n */\nfunction AbsoluteRedirect(urlTree) {\n  _classCallCheck(this, AbsoluteRedirect);\n\n  this.urlTree = urlTree;\n});\n/**\n * @param {?} segmentGroup\n * @return {?}\n */\n\n\nfunction noMatch(segmentGroup) {\n  return new Observable(function (obs) {\n    return obs.error(new NoMatch(segmentGroup));\n  });\n}\n/**\n * @param {?} newTree\n * @return {?}\n */\n\n\nfunction absoluteRedirect(newTree) {\n  return new Observable(function (obs) {\n    return obs.error(new AbsoluteRedirect(newTree));\n  });\n}\n/**\n * @param {?} redirectTo\n * @return {?}\n */\n\n\nfunction namedOutletsRedirect(redirectTo) {\n  return new Observable(function (obs) {\n    return obs.error(new Error(\"Only absolute redirects can have named outlets. redirectTo: '\".concat(redirectTo, \"'\")));\n  });\n}\n/**\n * @param {?} route\n * @return {?}\n */\n\n\nfunction canLoadFails(route) {\n  return new Observable(function (obs) {\n    return obs.error(navigationCancelingError(\"Cannot load children because the guard of the route \\\"path: '\".concat(route.path, \"'\\\" returned false\")));\n  });\n}\n/**\n * Returns the `UrlTree` with the redirection applied.\n *\n * Lazy modules are loaded along the way.\n * @param {?} moduleInjector\n * @param {?} configLoader\n * @param {?} urlSerializer\n * @param {?} urlTree\n * @param {?} config\n * @return {?}\n */\n\n\nfunction applyRedirects(moduleInjector, configLoader, urlSerializer, urlTree, config) {\n  return new ApplyRedirects(moduleInjector, configLoader, urlSerializer, urlTree, config).apply();\n}\n\nvar ApplyRedirects = /*#__PURE__*/function () {\n  /**\n   * @param {?} moduleInjector\n   * @param {?} configLoader\n   * @param {?} urlSerializer\n   * @param {?} urlTree\n   * @param {?} config\n   */\n  function ApplyRedirects(moduleInjector, configLoader, urlSerializer, urlTree, config) {\n    _classCallCheck(this, ApplyRedirects);\n\n    this.configLoader = configLoader;\n    this.urlSerializer = urlSerializer;\n    this.urlTree = urlTree;\n    this.config = config;\n    this.allowRedirects = true;\n    this.ngModule = moduleInjector.get(NgModuleRef);\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(ApplyRedirects, [{\n    key: \"apply\",\n    value: function apply() {\n      var _this10 = this;\n\n      var\n      /** @type {?} */\n      expanded$ = this.expandSegmentGroup(this.ngModule, this.config, this.urlTree.root, PRIMARY_OUTLET);\n      var\n      /** @type {?} */\n      urlTrees$ = map.call(expanded$, function (rootSegmentGroup) {\n        return _this10.createUrlTree(rootSegmentGroup, _this10.urlTree.queryParams,\n        /** @type {?} */\n        _this10.urlTree.fragment);\n      });\n      return _catch.call(urlTrees$, function (e) {\n        if (e instanceof AbsoluteRedirect) {\n          // after an absolute redirect we do not apply any more redirects!\n          _this10.allowRedirects = false; // we need to run matching, so we can fetch all lazy-loaded modules\n\n          return _this10.match(e.urlTree);\n        }\n\n        if (e instanceof NoMatch) {\n          throw _this10.noMatchError(e);\n        }\n\n        throw e;\n      });\n    }\n    /**\n     * @param {?} tree\n     * @return {?}\n     */\n\n  }, {\n    key: \"match\",\n    value: function match(tree) {\n      var _this11 = this;\n\n      var\n      /** @type {?} */\n      expanded$ = this.expandSegmentGroup(this.ngModule, this.config, tree.root, PRIMARY_OUTLET);\n      var\n      /** @type {?} */\n      mapped$ = map.call(expanded$, function (rootSegmentGroup) {\n        return _this11.createUrlTree(rootSegmentGroup, tree.queryParams,\n        /** @type {?} */\n        tree.fragment);\n      });\n      return _catch.call(mapped$, function (e) {\n        if (e instanceof NoMatch) {\n          throw _this11.noMatchError(e);\n        }\n\n        throw e;\n      });\n    }\n    /**\n     * @param {?} e\n     * @return {?}\n     */\n\n  }, {\n    key: \"noMatchError\",\n    value: function noMatchError(e) {\n      return new Error(\"Cannot match any routes. URL Segment: '\".concat(e.segmentGroup, \"'\"));\n    }\n    /**\n     * @param {?} rootCandidate\n     * @param {?} queryParams\n     * @param {?} fragment\n     * @return {?}\n     */\n\n  }, {\n    key: \"createUrlTree\",\n    value: function createUrlTree(rootCandidate, queryParams, fragment) {\n      var\n      /** @type {?} */\n      root = rootCandidate.segments.length > 0 ? new UrlSegmentGroup([], _defineProperty({}, PRIMARY_OUTLET, rootCandidate)) : rootCandidate;\n      return new UrlTree(root, queryParams, fragment);\n    }\n    /**\n     * @param {?} ngModule\n     * @param {?} routes\n     * @param {?} segmentGroup\n     * @param {?} outlet\n     * @return {?}\n     */\n\n  }, {\n    key: \"expandSegmentGroup\",\n    value: function expandSegmentGroup(ngModule, routes, segmentGroup, outlet) {\n      if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n        return map.call(this.expandChildren(ngModule, routes, segmentGroup), function (children) {\n          return new UrlSegmentGroup([], children);\n        });\n      }\n\n      return this.expandSegment(ngModule, segmentGroup, routes, segmentGroup.segments, outlet, true);\n    }\n    /**\n     * @param {?} ngModule\n     * @param {?} routes\n     * @param {?} segmentGroup\n     * @return {?}\n     */\n\n  }, {\n    key: \"expandChildren\",\n    value: function expandChildren(ngModule, routes, segmentGroup) {\n      var _this12 = this;\n\n      return waitForMap(segmentGroup.children, function (childOutlet, child) {\n        return _this12.expandSegmentGroup(ngModule, routes, child, childOutlet);\n      });\n    }\n    /**\n     * @param {?} ngModule\n     * @param {?} segmentGroup\n     * @param {?} routes\n     * @param {?} segments\n     * @param {?} outlet\n     * @param {?} allowRedirects\n     * @return {?}\n     */\n\n  }, {\n    key: \"expandSegment\",\n    value: function expandSegment(ngModule, segmentGroup, routes, segments, outlet, allowRedirects) {\n      var _this13 = this;\n\n      var\n      /** @type {?} */\n      routes$ = of.apply(void 0, _toConsumableArray(routes));\n      var\n      /** @type {?} */\n      processedRoutes$ = map.call(routes$, function (r) {\n        var\n        /** @type {?} */\n        expanded$ = _this13.expandSegmentAgainstRoute(ngModule, segmentGroup, routes, r, segments, outlet, allowRedirects);\n\n        return _catch.call(expanded$, function (e) {\n          if (e instanceof NoMatch) {\n            return of(null);\n          }\n\n          throw e;\n        });\n      });\n      var\n      /** @type {?} */\n      concattedProcessedRoutes$ = concatAll.call(processedRoutes$);\n      var\n      /** @type {?} */\n      first$ = first.call(concattedProcessedRoutes$, function (s) {\n        return !!s;\n      });\n      return _catch.call(first$, function (e, _) {\n        if (e instanceof EmptyError || e.name === 'EmptyError') {\n          if (_this13.noLeftoversInUrl(segmentGroup, segments, outlet)) {\n            return of(new UrlSegmentGroup([], {}));\n          }\n\n          throw new NoMatch(segmentGroup);\n        }\n\n        throw e;\n      });\n    }\n    /**\n     * @param {?} segmentGroup\n     * @param {?} segments\n     * @param {?} outlet\n     * @return {?}\n     */\n\n  }, {\n    key: \"noLeftoversInUrl\",\n    value: function noLeftoversInUrl(segmentGroup, segments, outlet) {\n      return segments.length === 0 && !segmentGroup.children[outlet];\n    }\n    /**\n     * @param {?} ngModule\n     * @param {?} segmentGroup\n     * @param {?} routes\n     * @param {?} route\n     * @param {?} paths\n     * @param {?} outlet\n     * @param {?} allowRedirects\n     * @return {?}\n     */\n\n  }, {\n    key: \"expandSegmentAgainstRoute\",\n    value: function expandSegmentAgainstRoute(ngModule, segmentGroup, routes, route, paths, outlet, allowRedirects) {\n      if (getOutlet(route) !== outlet) {\n        return noMatch(segmentGroup);\n      }\n\n      if (route.redirectTo === undefined) {\n        return this.matchSegmentAgainstRoute(ngModule, segmentGroup, route, paths);\n      }\n\n      if (allowRedirects && this.allowRedirects) {\n        return this.expandSegmentAgainstRouteUsingRedirect(ngModule, segmentGroup, routes, route, paths, outlet);\n      }\n\n      return noMatch(segmentGroup);\n    }\n    /**\n     * @param {?} ngModule\n     * @param {?} segmentGroup\n     * @param {?} routes\n     * @param {?} route\n     * @param {?} segments\n     * @param {?} outlet\n     * @return {?}\n     */\n\n  }, {\n    key: \"expandSegmentAgainstRouteUsingRedirect\",\n    value: function expandSegmentAgainstRouteUsingRedirect(ngModule, segmentGroup, routes, route, segments, outlet) {\n      if (route.path === '**') {\n        return this.expandWildCardWithParamsAgainstRouteUsingRedirect(ngModule, routes, route, outlet);\n      }\n\n      return this.expandRegularSegmentAgainstRouteUsingRedirect(ngModule, segmentGroup, routes, route, segments, outlet);\n    }\n    /**\n     * @param {?} ngModule\n     * @param {?} routes\n     * @param {?} route\n     * @param {?} outlet\n     * @return {?}\n     */\n\n  }, {\n    key: \"expandWildCardWithParamsAgainstRouteUsingRedirect\",\n    value: function expandWildCardWithParamsAgainstRouteUsingRedirect(ngModule, routes, route, outlet) {\n      var _this14 = this;\n\n      var\n      /** @type {?} */\n      newTree = this.applyRedirectCommands([],\n      /** @type {?} */\n      route.redirectTo, {});\n\n      if (\n      /** @type {?} */\n      route.redirectTo.startsWith('/')) {\n        return absoluteRedirect(newTree);\n      }\n\n      return mergeMap.call(this.lineralizeSegments(route, newTree), function (newSegments) {\n        var\n        /** @type {?} */\n        group = new UrlSegmentGroup(newSegments, {});\n        return _this14.expandSegment(ngModule, group, routes, newSegments, outlet, false);\n      });\n    }\n    /**\n     * @param {?} ngModule\n     * @param {?} segmentGroup\n     * @param {?} routes\n     * @param {?} route\n     * @param {?} segments\n     * @param {?} outlet\n     * @return {?}\n     */\n\n  }, {\n    key: \"expandRegularSegmentAgainstRouteUsingRedirect\",\n    value: function expandRegularSegmentAgainstRouteUsingRedirect(ngModule, segmentGroup, routes, route, segments, outlet) {\n      var _this15 = this;\n\n      var _match = match(segmentGroup, route, segments),\n          matched = _match.matched,\n          consumedSegments = _match.consumedSegments,\n          lastChild = _match.lastChild,\n          positionalParamSegments = _match.positionalParamSegments;\n\n      if (!matched) return noMatch(segmentGroup);\n      var\n      /** @type {?} */\n      newTree = this.applyRedirectCommands(consumedSegments,\n      /** @type {?} */\n      route.redirectTo,\n      /** @type {?} */\n      positionalParamSegments);\n\n      if (\n      /** @type {?} */\n      route.redirectTo.startsWith('/')) {\n        return absoluteRedirect(newTree);\n      }\n\n      return mergeMap.call(this.lineralizeSegments(route, newTree), function (newSegments) {\n        return _this15.expandSegment(ngModule, segmentGroup, routes, newSegments.concat(segments.slice(lastChild)), outlet, false);\n      });\n    }\n    /**\n     * @param {?} ngModule\n     * @param {?} rawSegmentGroup\n     * @param {?} route\n     * @param {?} segments\n     * @return {?}\n     */\n\n  }, {\n    key: \"matchSegmentAgainstRoute\",\n    value: function matchSegmentAgainstRoute(ngModule, rawSegmentGroup, route, segments) {\n      var _this16 = this;\n\n      if (route.path === '**') {\n        if (route.loadChildren) {\n          return map.call(this.configLoader.load(ngModule.injector, route), function (cfg) {\n            route._loadedConfig = cfg;\n            return new UrlSegmentGroup(segments, {});\n          });\n        }\n\n        return of(new UrlSegmentGroup(segments, {}));\n      }\n\n      var _match2 = match(rawSegmentGroup, route, segments),\n          matched = _match2.matched,\n          consumedSegments = _match2.consumedSegments,\n          lastChild = _match2.lastChild;\n\n      if (!matched) return noMatch(rawSegmentGroup);\n      var\n      /** @type {?} */\n      rawSlicedSegments = segments.slice(lastChild);\n      var\n      /** @type {?} */\n      childConfig$ = this.getChildConfig(ngModule, route);\n      return mergeMap.call(childConfig$, function (routerConfig) {\n        var\n        /** @type {?} */\n        childModule = routerConfig.module;\n        var\n        /** @type {?} */\n        childConfig = routerConfig.routes;\n\n        var _split = split(rawSegmentGroup, consumedSegments, rawSlicedSegments, childConfig),\n            segmentGroup = _split.segmentGroup,\n            slicedSegments = _split.slicedSegments;\n\n        if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {\n          var\n          /** @type {?} */\n          _expanded$ = _this16.expandChildren(childModule, childConfig, segmentGroup);\n\n          return map.call(_expanded$, function (children) {\n            return new UrlSegmentGroup(consumedSegments, children);\n          });\n        }\n\n        if (childConfig.length === 0 && slicedSegments.length === 0) {\n          return of(new UrlSegmentGroup(consumedSegments, {}));\n        }\n\n        var\n        /** @type {?} */\n        expanded$ = _this16.expandSegment(childModule, segmentGroup, childConfig, slicedSegments, PRIMARY_OUTLET, true);\n\n        return map.call(expanded$, function (cs) {\n          return new UrlSegmentGroup(consumedSegments.concat(cs.segments), cs.children);\n        });\n      });\n    }\n    /**\n     * @param {?} ngModule\n     * @param {?} route\n     * @return {?}\n     */\n\n  }, {\n    key: \"getChildConfig\",\n    value: function getChildConfig(ngModule, route) {\n      var _this17 = this;\n\n      if (route.children) {\n        // The children belong to the same module\n        return of(new LoadedRouterConfig(route.children, ngModule));\n      }\n\n      if (route.loadChildren) {\n        // lazy children belong to the loaded module\n        if (route._loadedConfig !== undefined) {\n          return of(route._loadedConfig);\n        }\n\n        return mergeMap.call(runCanLoadGuard(ngModule.injector, route), function (shouldLoad) {\n          if (shouldLoad) {\n            return map.call(_this17.configLoader.load(ngModule.injector, route), function (cfg) {\n              route._loadedConfig = cfg;\n              return cfg;\n            });\n          }\n\n          return canLoadFails(route);\n        });\n      }\n\n      return of(new LoadedRouterConfig([], ngModule));\n    }\n    /**\n     * @param {?} route\n     * @param {?} urlTree\n     * @return {?}\n     */\n\n  }, {\n    key: \"lineralizeSegments\",\n    value: function lineralizeSegments(route, urlTree) {\n      var\n      /** @type {?} */\n      res = [];\n      var\n      /** @type {?} */\n      c = urlTree.root;\n\n      while (true) {\n        res = res.concat(c.segments);\n\n        if (c.numberOfChildren === 0) {\n          return of(res);\n        }\n\n        if (c.numberOfChildren > 1 || !c.children[PRIMARY_OUTLET]) {\n          return namedOutletsRedirect(\n          /** @type {?} */\n          route.redirectTo);\n        }\n\n        c = c.children[PRIMARY_OUTLET];\n      }\n    }\n    /**\n     * @param {?} segments\n     * @param {?} redirectTo\n     * @param {?} posParams\n     * @return {?}\n     */\n\n  }, {\n    key: \"applyRedirectCommands\",\n    value: function applyRedirectCommands(segments, redirectTo, posParams) {\n      return this.applyRedirectCreatreUrlTree(redirectTo, this.urlSerializer.parse(redirectTo), segments, posParams);\n    }\n    /**\n     * @param {?} redirectTo\n     * @param {?} urlTree\n     * @param {?} segments\n     * @param {?} posParams\n     * @return {?}\n     */\n\n  }, {\n    key: \"applyRedirectCreatreUrlTree\",\n    value: function applyRedirectCreatreUrlTree(redirectTo, urlTree, segments, posParams) {\n      var\n      /** @type {?} */\n      newRoot = this.createSegmentGroup(redirectTo, urlTree.root, segments, posParams);\n      return new UrlTree(newRoot, this.createQueryParams(urlTree.queryParams, this.urlTree.queryParams), urlTree.fragment);\n    }\n    /**\n     * @param {?} redirectToParams\n     * @param {?} actualParams\n     * @return {?}\n     */\n\n  }, {\n    key: \"createQueryParams\",\n    value: function createQueryParams(redirectToParams, actualParams) {\n      var\n      /** @type {?} */\n      res = {};\n      forEach(redirectToParams, function (v, k) {\n        var\n        /** @type {?} */\n        copySourceValue = typeof v === 'string' && v.startsWith(':');\n\n        if (copySourceValue) {\n          var\n          /** @type {?} */\n          sourceName = v.substring(1);\n          res[k] = actualParams[sourceName];\n        } else {\n          res[k] = v;\n        }\n      });\n      return res;\n    }\n    /**\n     * @param {?} redirectTo\n     * @param {?} group\n     * @param {?} segments\n     * @param {?} posParams\n     * @return {?}\n     */\n\n  }, {\n    key: \"createSegmentGroup\",\n    value: function createSegmentGroup(redirectTo, group, segments, posParams) {\n      var _this18 = this;\n\n      var\n      /** @type {?} */\n      updatedSegments = this.createSegments(redirectTo, group.segments, segments, posParams);\n      var\n      /** @type {?} */\n      children = {};\n      forEach(group.children, function (child, name) {\n        children[name] = _this18.createSegmentGroup(redirectTo, child, segments, posParams);\n      });\n      return new UrlSegmentGroup(updatedSegments, children);\n    }\n    /**\n     * @param {?} redirectTo\n     * @param {?} redirectToSegments\n     * @param {?} actualSegments\n     * @param {?} posParams\n     * @return {?}\n     */\n\n  }, {\n    key: \"createSegments\",\n    value: function createSegments(redirectTo, redirectToSegments, actualSegments, posParams) {\n      var _this19 = this;\n\n      return redirectToSegments.map(function (s) {\n        return s.path.startsWith(':') ? _this19.findPosParam(redirectTo, s, posParams) : _this19.findOrReturn(s, actualSegments);\n      });\n    }\n    /**\n     * @param {?} redirectTo\n     * @param {?} redirectToUrlSegment\n     * @param {?} posParams\n     * @return {?}\n     */\n\n  }, {\n    key: \"findPosParam\",\n    value: function findPosParam(redirectTo, redirectToUrlSegment, posParams) {\n      var\n      /** @type {?} */\n      pos = posParams[redirectToUrlSegment.path.substring(1)];\n      if (!pos) throw new Error(\"Cannot redirect to '\".concat(redirectTo, \"'. Cannot find '\").concat(redirectToUrlSegment.path, \"'.\"));\n      return pos;\n    }\n    /**\n     * @param {?} redirectToUrlSegment\n     * @param {?} actualSegments\n     * @return {?}\n     */\n\n  }, {\n    key: \"findOrReturn\",\n    value: function findOrReturn(redirectToUrlSegment, actualSegments) {\n      var\n      /** @type {?} */\n      idx = 0;\n\n      var _iterator = _createForOfIteratorHelper(actualSegments),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var s = _step.value;\n\n          if (s.path === redirectToUrlSegment.path) {\n            actualSegments.splice(idx);\n            return s;\n          }\n\n          idx++;\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return redirectToUrlSegment;\n    }\n  }]);\n\n  return ApplyRedirects;\n}();\n/**\n * @param {?} moduleInjector\n * @param {?} route\n * @return {?}\n */\n\n\nfunction runCanLoadGuard(moduleInjector, route) {\n  var\n  /** @type {?} */\n  canLoad = route.canLoad;\n  if (!canLoad || canLoad.length === 0) return of(true);\n  var\n  /** @type {?} */\n  obs = map.call(from(canLoad), function (injectionToken) {\n    var\n    /** @type {?} */\n    guard = moduleInjector.get(injectionToken);\n    return wrapIntoObservable(guard.canLoad ? guard.canLoad(route) : guard(route));\n  });\n  return andObservables(obs);\n}\n/**\n * @param {?} segmentGroup\n * @param {?} route\n * @param {?} segments\n * @return {?}\n */\n\n\nfunction match(segmentGroup, route, segments) {\n  if (route.path === '') {\n    if (route.pathMatch === 'full' && (segmentGroup.hasChildren() || segments.length > 0)) {\n      return {\n        matched: false,\n        consumedSegments: [],\n        lastChild: 0,\n        positionalParamSegments: {}\n      };\n    }\n\n    return {\n      matched: true,\n      consumedSegments: [],\n      lastChild: 0,\n      positionalParamSegments: {}\n    };\n  }\n\n  var\n  /** @type {?} */\n  matcher = route.matcher || defaultUrlMatcher;\n  var\n  /** @type {?} */\n  res = matcher(segments, segmentGroup, route);\n\n  if (!res) {\n    return {\n      matched: false,\n      consumedSegments:\n      /** @type {?} */\n      [],\n      lastChild: 0,\n      positionalParamSegments: {}\n    };\n  }\n\n  return {\n    matched: true,\n    consumedSegments:\n    /** @type {?} */\n    res.consumed,\n    lastChild:\n    /** @type {?} */\n    res.consumed.length,\n    positionalParamSegments:\n    /** @type {?} */\n    res.posParams\n  };\n}\n/**\n * @param {?} segmentGroup\n * @param {?} consumedSegments\n * @param {?} slicedSegments\n * @param {?} config\n * @return {?}\n */\n\n\nfunction split(segmentGroup, consumedSegments, slicedSegments, config) {\n  if (slicedSegments.length > 0 && containsEmptyPathRedirectsWithNamedOutlets(segmentGroup, slicedSegments, config)) {\n    var\n    /** @type {?} */\n    s = new UrlSegmentGroup(consumedSegments, createChildrenForEmptySegments(config, new UrlSegmentGroup(slicedSegments, segmentGroup.children)));\n    return {\n      segmentGroup: mergeTrivialChildren(s),\n      slicedSegments: []\n    };\n  }\n\n  if (slicedSegments.length === 0 && containsEmptyPathRedirects(segmentGroup, slicedSegments, config)) {\n    var\n    /** @type {?} */\n    _s = new UrlSegmentGroup(segmentGroup.segments, addEmptySegmentsToChildrenIfNeeded(segmentGroup, slicedSegments, config, segmentGroup.children));\n\n    return {\n      segmentGroup: mergeTrivialChildren(_s),\n      slicedSegments: slicedSegments\n    };\n  }\n\n  return {\n    segmentGroup: segmentGroup,\n    slicedSegments: slicedSegments\n  };\n}\n/**\n * @param {?} s\n * @return {?}\n */\n\n\nfunction mergeTrivialChildren(s) {\n  if (s.numberOfChildren === 1 && s.children[PRIMARY_OUTLET]) {\n    var\n    /** @type {?} */\n    c = s.children[PRIMARY_OUTLET];\n    return new UrlSegmentGroup(s.segments.concat(c.segments), c.children);\n  }\n\n  return s;\n}\n/**\n * @param {?} segmentGroup\n * @param {?} slicedSegments\n * @param {?} routes\n * @param {?} children\n * @return {?}\n */\n\n\nfunction addEmptySegmentsToChildrenIfNeeded(segmentGroup, slicedSegments, routes, children) {\n  var\n  /** @type {?} */\n  res = {};\n\n  var _iterator2 = _createForOfIteratorHelper(routes),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var r = _step2.value;\n\n      if (isEmptyPathRedirect(segmentGroup, slicedSegments, r) && !children[getOutlet(r)]) {\n        res[getOutlet(r)] = new UrlSegmentGroup([], {});\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return Object.assign({}, children, res);\n}\n/**\n * @param {?} routes\n * @param {?} primarySegmentGroup\n * @return {?}\n */\n\n\nfunction createChildrenForEmptySegments(routes, primarySegmentGroup) {\n  var\n  /** @type {?} */\n  res = {};\n  res[PRIMARY_OUTLET] = primarySegmentGroup;\n\n  var _iterator3 = _createForOfIteratorHelper(routes),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var r = _step3.value;\n\n      if (r.path === '' && getOutlet(r) !== PRIMARY_OUTLET) {\n        res[getOutlet(r)] = new UrlSegmentGroup([], {});\n      }\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  return res;\n}\n/**\n * @param {?} segmentGroup\n * @param {?} segments\n * @param {?} routes\n * @return {?}\n */\n\n\nfunction containsEmptyPathRedirectsWithNamedOutlets(segmentGroup, segments, routes) {\n  return routes.some(function (r) {\n    return isEmptyPathRedirect(segmentGroup, segments, r) && getOutlet(r) !== PRIMARY_OUTLET;\n  });\n}\n/**\n * @param {?} segmentGroup\n * @param {?} segments\n * @param {?} routes\n * @return {?}\n */\n\n\nfunction containsEmptyPathRedirects(segmentGroup, segments, routes) {\n  return routes.some(function (r) {\n    return isEmptyPathRedirect(segmentGroup, segments, r);\n  });\n}\n/**\n * @param {?} segmentGroup\n * @param {?} segments\n * @param {?} r\n * @return {?}\n */\n\n\nfunction isEmptyPathRedirect(segmentGroup, segments, r) {\n  if ((segmentGroup.hasChildren() || segments.length > 0) && r.pathMatch === 'full') {\n    return false;\n  }\n\n  return r.path === '' && r.redirectTo !== undefined;\n}\n/**\n * @param {?} route\n * @return {?}\n */\n\n\nfunction getOutlet(route) {\n  return route.outlet || PRIMARY_OUTLET;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @template T\n */\n\n\nvar Tree = /*#__PURE__*/function () {\n  /**\n   * @param {?} root\n   */\n  function Tree(root) {\n    _classCallCheck(this, Tree);\n\n    this._root = root;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(Tree, [{\n    key: \"root\",\n    get: function get() {\n      return this._root.value;\n    }\n    /**\n     * \\@internal\n     * @param {?} t\n     * @return {?}\n     */\n\n  }, {\n    key: \"parent\",\n    value: function parent(t) {\n      var\n      /** @type {?} */\n      p = this.pathFromRoot(t);\n      return p.length > 1 ? p[p.length - 2] : null;\n    }\n    /**\n     * \\@internal\n     * @param {?} t\n     * @return {?}\n     */\n\n  }, {\n    key: \"children\",\n    value: function children(t) {\n      var\n      /** @type {?} */\n      n = findNode(t, this._root);\n      return n ? n.children.map(function (t) {\n        return t.value;\n      }) : [];\n    }\n    /**\n     * \\@internal\n     * @param {?} t\n     * @return {?}\n     */\n\n  }, {\n    key: \"firstChild\",\n    value: function firstChild(t) {\n      var\n      /** @type {?} */\n      n = findNode(t, this._root);\n      return n && n.children.length > 0 ? n.children[0].value : null;\n    }\n    /**\n     * \\@internal\n     * @param {?} t\n     * @return {?}\n     */\n\n  }, {\n    key: \"siblings\",\n    value: function siblings(t) {\n      var\n      /** @type {?} */\n      p = findPath(t, this._root);\n      if (p.length < 2) return [];\n      var\n      /** @type {?} */\n      c = p[p.length - 2].children.map(function (c) {\n        return c.value;\n      });\n      return c.filter(function (cc) {\n        return cc !== t;\n      });\n    }\n    /**\n     * \\@internal\n     * @param {?} t\n     * @return {?}\n     */\n\n  }, {\n    key: \"pathFromRoot\",\n    value: function pathFromRoot(t) {\n      return findPath(t, this._root).map(function (s) {\n        return s.value;\n      });\n    }\n  }]);\n\n  return Tree;\n}();\n/**\n * @template T\n * @param {?} value\n * @param {?} node\n * @return {?}\n */\n\n\nfunction findNode(value, node) {\n  if (value === node.value) return node;\n\n  var _iterator4 = _createForOfIteratorHelper(node.children),\n      _step4;\n\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var child = _step4.value;\n\n      var\n      /** @type {?} */\n      _node = findNode(value, child);\n\n      if (_node) return _node;\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n\n  return null;\n}\n/**\n * @template T\n * @param {?} value\n * @param {?} node\n * @return {?}\n */\n\n\nfunction findPath(value, node) {\n  if (value === node.value) return [node];\n\n  var _iterator5 = _createForOfIteratorHelper(node.children),\n      _step5;\n\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      var child = _step5.value;\n      var\n      /** @type {?} */\n      path = findPath(value, child);\n\n      if (path.length) {\n        path.unshift(node);\n        return path;\n      }\n    }\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n\n  return [];\n}\n/**\n * @template T\n */\n\n\nvar TreeNode = /*#__PURE__*/function () {\n  /**\n   * @param {?} value\n   * @param {?} children\n   */\n  function TreeNode(value, children) {\n    _classCallCheck(this, TreeNode);\n\n    this.value = value;\n    this.children = children;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(TreeNode, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"TreeNode(\".concat(this.value, \")\");\n    }\n  }]);\n\n  return TreeNode;\n}();\n/**\n * @template T\n * @param {?} node\n * @return {?}\n */\n\n\nfunction nodeChildrenAsMap(node) {\n  var\n  /** @type {?} */\n  map$$1 = {};\n\n  if (node) {\n    node.children.forEach(function (child) {\n      return map$$1[child.value.outlet] = child;\n    });\n  }\n\n  return map$$1;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * \\@whatItDoes Represents the state of the router.\n *\n * \\@howToUse\n *\n * ```\n * \\@Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const state: RouterState = router.routerState;\n *     const root: ActivatedRoute = state.root;\n *     const child = root.firstChild;\n *     const id: Observable<string> = child.params.map(p => p.id);\n *     //...\n *   }\n * }\n * ```\n *\n * \\@description\n * RouterState is a tree of activated routes. Every node in this tree knows about the \"consumed\" URL\n * segments, the extracted parameters, and the resolved data.\n *\n * See {\\@link ActivatedRoute} for more information.\n *\n * \\@stable\n */\n\n\nvar RouterState = /*#__PURE__*/function (_Tree) {\n  _inherits(RouterState, _Tree);\n\n  var _super10 = _createSuper(RouterState);\n\n  /**\n   * \\@internal\n   * @param {?} root\n   * @param {?} snapshot\n   */\n  function RouterState(root, snapshot) {\n    var _this20;\n\n    _classCallCheck(this, RouterState);\n\n    _this20 = _super10.call(this, root);\n    _this20.snapshot = snapshot;\n    setRouterState(\n    /** @type {?} */\n    _assertThisInitialized(_this20), root);\n    return _this20;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(RouterState, [{\n    key: \"toString\",\n    value: function toString() {\n      return this.snapshot.toString();\n    }\n  }]);\n\n  return RouterState;\n}(Tree);\n/**\n * @param {?} urlTree\n * @param {?} rootComponent\n * @return {?}\n */\n\n\nfunction createEmptyState(urlTree, rootComponent) {\n  var\n  /** @type {?} */\n  snapshot = createEmptyStateSnapshot(urlTree, rootComponent);\n  var\n  /** @type {?} */\n  emptyUrl = new BehaviorSubject([new UrlSegment('', {})]);\n  var\n  /** @type {?} */\n  emptyParams = new BehaviorSubject({});\n  var\n  /** @type {?} */\n  emptyData = new BehaviorSubject({});\n  var\n  /** @type {?} */\n  emptyQueryParams = new BehaviorSubject({});\n  var\n  /** @type {?} */\n  fragment = new BehaviorSubject('');\n  var\n  /** @type {?} */\n  activated = new ActivatedRoute(emptyUrl, emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, snapshot.root);\n  activated.snapshot = snapshot.root;\n  return new RouterState(new TreeNode(activated, []), snapshot);\n}\n/**\n * @param {?} urlTree\n * @param {?} rootComponent\n * @return {?}\n */\n\n\nfunction createEmptyStateSnapshot(urlTree, rootComponent) {\n  var\n  /** @type {?} */\n  emptyParams = {};\n  var\n  /** @type {?} */\n  emptyData = {};\n  var\n  /** @type {?} */\n  emptyQueryParams = {};\n  var\n  /** @type {?} */\n  fragment = '';\n  var\n  /** @type {?} */\n  activated = new ActivatedRouteSnapshot([], emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, null, urlTree.root, -1, {});\n  return new RouterStateSnapshot('', new TreeNode(activated, []));\n}\n/**\n * \\@whatItDoes Contains the information about a route associated with a component loaded in an\n * outlet.\n * An `ActivatedRoute` can also be used to traverse the router state tree.\n *\n * \\@howToUse\n *\n * ```\n * \\@Component({...})\n * class MyComponent {\n *   constructor(route: ActivatedRoute) {\n *     const id: Observable<string> = route.params.map(p => p.id);\n *     const url: Observable<string> = route.url.map(segments => segments.join(''));\n *     // route.data includes both `data` and `resolve`\n *     const user = route.data.map(d => d.user);\n *   }\n * }\n * ```\n *\n * \\@stable\n */\n\n\nvar ActivatedRoute = /*#__PURE__*/function () {\n  /**\n   * \\@internal\n   * @param {?} url\n   * @param {?} params\n   * @param {?} queryParams\n   * @param {?} fragment\n   * @param {?} data\n   * @param {?} outlet\n   * @param {?} component\n   * @param {?} futureSnapshot\n   */\n  function ActivatedRoute(url, params, queryParams, fragment, data, outlet, component, futureSnapshot) {\n    _classCallCheck(this, ActivatedRoute);\n\n    this.url = url;\n    this.params = params;\n    this.queryParams = queryParams;\n    this.fragment = fragment;\n    this.data = data;\n    this.outlet = outlet;\n    this.component = component;\n    this._futureSnapshot = futureSnapshot;\n  }\n  /**\n   * The configuration used to match this route\n   * @return {?}\n   */\n\n\n  _createClass(ActivatedRoute, [{\n    key: \"routeConfig\",\n    get: function get() {\n      return this._futureSnapshot.routeConfig;\n    }\n    /**\n     * The root of the router state\n     * @return {?}\n     */\n\n  }, {\n    key: \"root\",\n    get: function get() {\n      return this._routerState.root;\n    }\n    /**\n     * The parent of this route in the router state tree\n     * @return {?}\n     */\n\n  }, {\n    key: \"parent\",\n    get: function get() {\n      return this._routerState.parent(this);\n    }\n    /**\n     * The first child of this route in the router state tree\n     * @return {?}\n     */\n\n  }, {\n    key: \"firstChild\",\n    get: function get() {\n      return this._routerState.firstChild(this);\n    }\n    /**\n     * The children of this route in the router state tree\n     * @return {?}\n     */\n\n  }, {\n    key: \"children\",\n    get: function get() {\n      return this._routerState.children(this);\n    }\n    /**\n     * The path from the root of the router state tree to this route\n     * @return {?}\n     */\n\n  }, {\n    key: \"pathFromRoot\",\n    get: function get() {\n      return this._routerState.pathFromRoot(this);\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"paramMap\",\n    get: function get() {\n      if (!this._paramMap) {\n        this._paramMap = map.call(this.params, function (p) {\n          return convertToParamMap(p);\n        });\n      }\n\n      return this._paramMap;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"queryParamMap\",\n    get: function get() {\n      if (!this._queryParamMap) {\n        this._queryParamMap = map.call(this.queryParams, function (p) {\n          return convertToParamMap(p);\n        });\n      }\n\n      return this._queryParamMap;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.snapshot ? this.snapshot.toString() : \"Future(\".concat(this._futureSnapshot, \")\");\n    }\n  }]);\n\n  return ActivatedRoute;\n}();\n/**\n * Returns the inherited params, data, and resolve for a given route.\n * By default, this only inherits values up to the nearest path-less or component-less route.\n * \\@internal\n * @param {?} route\n * @param {?=} paramsInheritanceStrategy\n * @return {?}\n */\n\n\nfunction inheritedParamsDataResolve(route) {\n  var paramsInheritanceStrategy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'emptyOnly';\n  var\n  /** @type {?} */\n  pathFromRoot = route.pathFromRoot;\n  var\n  /** @type {?} */\n  inheritingStartingFrom = 0;\n\n  if (paramsInheritanceStrategy !== 'always') {\n    inheritingStartingFrom = pathFromRoot.length - 1;\n\n    while (inheritingStartingFrom >= 1) {\n      var\n      /** @type {?} */\n      current = pathFromRoot[inheritingStartingFrom];\n      var\n      /** @type {?} */\n      parent = pathFromRoot[inheritingStartingFrom - 1]; // current route is an empty path => inherits its parent's params and data\n\n      if (current.routeConfig && current.routeConfig.path === '') {\n        inheritingStartingFrom--; // parent is componentless => current route should inherit its params and data\n      } else if (!parent.component) {\n        inheritingStartingFrom--;\n      } else {\n        break;\n      }\n    }\n  }\n\n  return flattenInherited(pathFromRoot.slice(inheritingStartingFrom));\n}\n/**\n * \\@internal\n * @param {?} pathFromRoot\n * @return {?}\n */\n\n\nfunction flattenInherited(pathFromRoot) {\n  return pathFromRoot.reduce(function (res, curr) {\n    var\n    /** @type {?} */\n    params = Object.assign({}, res.params, curr.params);\n    var\n    /** @type {?} */\n    data = Object.assign({}, res.data, curr.data);\n    var\n    /** @type {?} */\n    resolve = Object.assign({}, res.resolve, curr._resolvedData);\n    return {\n      params: params,\n      data: data,\n      resolve: resolve\n    };\n  },\n  /** @type {?} */\n  {\n    params: {},\n    data: {},\n    resolve: {}\n  });\n}\n/**\n * \\@whatItDoes Contains the information about a route associated with a component loaded in an\n * outlet\n * at a particular moment in time. ActivatedRouteSnapshot can also be used to traverse the router\n * state tree.\n *\n * \\@howToUse\n *\n * ```\n * \\@Component({templateUrl:'./my-component.html'})\n * class MyComponent {\n *   constructor(route: ActivatedRoute) {\n *     const id: string = route.snapshot.params.id;\n *     const url: string = route.snapshot.url.join('');\n *     const user = route.snapshot.data.user;\n *   }\n * }\n * ```\n *\n * \\@stable\n */\n\n\nvar ActivatedRouteSnapshot = /*#__PURE__*/function () {\n  /**\n   * \\@internal\n   * @param {?} url\n   * @param {?} params\n   * @param {?} queryParams\n   * @param {?} fragment\n   * @param {?} data\n   * @param {?} outlet\n   * @param {?} component\n   * @param {?} routeConfig\n   * @param {?} urlSegment\n   * @param {?} lastPathIndex\n   * @param {?} resolve\n   */\n  function ActivatedRouteSnapshot(url, params, queryParams, fragment, data, outlet, component, routeConfig, urlSegment, lastPathIndex, resolve) {\n    _classCallCheck(this, ActivatedRouteSnapshot);\n\n    this.url = url;\n    this.params = params;\n    this.queryParams = queryParams;\n    this.fragment = fragment;\n    this.data = data;\n    this.outlet = outlet;\n    this.component = component;\n    this.routeConfig = routeConfig;\n    this._urlSegment = urlSegment;\n    this._lastPathIndex = lastPathIndex;\n    this._resolve = resolve;\n  }\n  /**\n   * The root of the router state\n   * @return {?}\n   */\n\n\n  _createClass(ActivatedRouteSnapshot, [{\n    key: \"root\",\n    get: function get() {\n      return this._routerState.root;\n    }\n    /**\n     * The parent of this route in the router state tree\n     * @return {?}\n     */\n\n  }, {\n    key: \"parent\",\n    get: function get() {\n      return this._routerState.parent(this);\n    }\n    /**\n     * The first child of this route in the router state tree\n     * @return {?}\n     */\n\n  }, {\n    key: \"firstChild\",\n    get: function get() {\n      return this._routerState.firstChild(this);\n    }\n    /**\n     * The children of this route in the router state tree\n     * @return {?}\n     */\n\n  }, {\n    key: \"children\",\n    get: function get() {\n      return this._routerState.children(this);\n    }\n    /**\n     * The path from the root of the router state tree to this route\n     * @return {?}\n     */\n\n  }, {\n    key: \"pathFromRoot\",\n    get: function get() {\n      return this._routerState.pathFromRoot(this);\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"paramMap\",\n    get: function get() {\n      if (!this._paramMap) {\n        this._paramMap = convertToParamMap(this.params);\n      }\n\n      return this._paramMap;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"queryParamMap\",\n    get: function get() {\n      if (!this._queryParamMap) {\n        this._queryParamMap = convertToParamMap(this.queryParams);\n      }\n\n      return this._queryParamMap;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var\n      /** @type {?} */\n      url = this.url.map(function (segment) {\n        return segment.toString();\n      }).join('/');\n      var\n      /** @type {?} */\n      matched = this.routeConfig ? this.routeConfig.path : '';\n      return \"Route(url:'\".concat(url, \"', path:'\").concat(matched, \"')\");\n    }\n  }]);\n\n  return ActivatedRouteSnapshot;\n}();\n/**\n * \\@whatItDoes Represents the state of the router at a moment in time.\n *\n * \\@howToUse\n *\n * ```\n * \\@Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const state: RouterState = router.routerState;\n *     const snapshot: RouterStateSnapshot = state.snapshot;\n *     const root: ActivatedRouteSnapshot = snapshot.root;\n *     const child = root.firstChild;\n *     const id: Observable<string> = child.params.map(p => p.id);\n *     //...\n *   }\n * }\n * ```\n *\n * \\@description\n * RouterStateSnapshot is a tree of activated route snapshots. Every node in this tree knows about\n * the \"consumed\" URL segments, the extracted parameters, and the resolved data.\n *\n * \\@stable\n */\n\n\nvar RouterStateSnapshot = /*#__PURE__*/function (_Tree2) {\n  _inherits(RouterStateSnapshot, _Tree2);\n\n  var _super11 = _createSuper(RouterStateSnapshot);\n\n  /**\n   * \\@internal\n   * @param {?} url\n   * @param {?} root\n   */\n  function RouterStateSnapshot(url, root) {\n    var _this21;\n\n    _classCallCheck(this, RouterStateSnapshot);\n\n    _this21 = _super11.call(this, root);\n    _this21.url = url;\n    setRouterState(\n    /** @type {?} */\n    _assertThisInitialized(_this21), root);\n    return _this21;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(RouterStateSnapshot, [{\n    key: \"toString\",\n    value: function toString() {\n      return serializeNode(this._root);\n    }\n  }]);\n\n  return RouterStateSnapshot;\n}(Tree);\n/**\n * @template U, T\n * @param {?} state\n * @param {?} node\n * @return {?}\n */\n\n\nfunction setRouterState(state, node) {\n  node.value._routerState = state;\n  node.children.forEach(function (c) {\n    return setRouterState(state, c);\n  });\n}\n/**\n * @param {?} node\n * @return {?}\n */\n\n\nfunction serializeNode(node) {\n  var\n  /** @type {?} */\n  c = node.children.length > 0 ? \" { \".concat(node.children.map(serializeNode).join(', '), \" } \") : '';\n  return \"\".concat(node.value).concat(c);\n}\n/**\n * The expectation is that the activate route is created with the right set of parameters.\n * So we push new values into the observables only when they are not the initial values.\n * And we detect that by checking if the snapshot field is set.\n * @param {?} route\n * @return {?}\n */\n\n\nfunction advanceActivatedRoute(route) {\n  if (route.snapshot) {\n    var\n    /** @type {?} */\n    currentSnapshot = route.snapshot;\n    var\n    /** @type {?} */\n    nextSnapshot = route._futureSnapshot;\n    route.snapshot = nextSnapshot;\n\n    if (!shallowEqual(currentSnapshot.queryParams, nextSnapshot.queryParams)) {\n      /** @type {?} */\n      route.queryParams.next(nextSnapshot.queryParams);\n    }\n\n    if (currentSnapshot.fragment !== nextSnapshot.fragment) {\n      /** @type {?} */\n      route.fragment.next(nextSnapshot.fragment);\n    }\n\n    if (!shallowEqual(currentSnapshot.params, nextSnapshot.params)) {\n      /** @type {?} */\n      route.params.next(nextSnapshot.params);\n    }\n\n    if (!shallowEqualArrays(currentSnapshot.url, nextSnapshot.url)) {\n      /** @type {?} */\n      route.url.next(nextSnapshot.url);\n    }\n\n    if (!shallowEqual(currentSnapshot.data, nextSnapshot.data)) {\n      /** @type {?} */\n      route.data.next(nextSnapshot.data);\n    }\n  } else {\n    route.snapshot = route._futureSnapshot; // this is for resolved data\n\n    /** @type {?} */\n    route.data.next(route._futureSnapshot.data);\n  }\n}\n/**\n * @param {?} a\n * @param {?} b\n * @return {?}\n */\n\n\nfunction equalParamsAndUrlSegments(a, b) {\n  var\n  /** @type {?} */\n  equalUrlParams = shallowEqual(a.params, b.params) && equalSegments(a.url, b.url);\n  var\n  /** @type {?} */\n  parentsMismatch = !a.parent !== !b.parent;\n  return equalUrlParams && !parentsMismatch && (!a.parent || equalParamsAndUrlSegments(a.parent,\n  /** @type {?} */\n  b.parent));\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @param {?} routeReuseStrategy\n * @param {?} curr\n * @param {?} prevState\n * @return {?}\n */\n\n\nfunction createRouterState(routeReuseStrategy, curr, prevState) {\n  var\n  /** @type {?} */\n  root = createNode(routeReuseStrategy, curr._root, prevState ? prevState._root : undefined);\n  return new RouterState(root, curr);\n}\n/**\n * @param {?} routeReuseStrategy\n * @param {?} curr\n * @param {?=} prevState\n * @return {?}\n */\n\n\nfunction createNode(routeReuseStrategy, curr, prevState) {\n  // reuse an activated route that is currently displayed on the screen\n  if (prevState && routeReuseStrategy.shouldReuseRoute(curr.value, prevState.value.snapshot)) {\n    var\n    /** @type {?} */\n    value = prevState.value;\n    value._futureSnapshot = curr.value;\n    var\n    /** @type {?} */\n    children = createOrReuseChildren(routeReuseStrategy, curr, prevState);\n    return new TreeNode(value, children); // retrieve an activated route that is used to be displayed, but is not currently displayed\n  } else if (routeReuseStrategy.retrieve(curr.value)) {\n    var\n    /** @type {?} */\n    _tree =\n    /** @type {?} */\n    routeReuseStrategy.retrieve(curr.value).route;\n    setFutureSnapshotsOfActivatedRoutes(curr, _tree);\n    return _tree;\n  } else {\n    var\n    /** @type {?} */\n    _value = createActivatedRoute(curr.value);\n\n    var\n    /** @type {?} */\n    _children2 = curr.children.map(function (c) {\n      return createNode(routeReuseStrategy, c);\n    });\n\n    return new TreeNode(_value, _children2);\n  }\n}\n/**\n * @param {?} curr\n * @param {?} result\n * @return {?}\n */\n\n\nfunction setFutureSnapshotsOfActivatedRoutes(curr, result) {\n  if (curr.value.routeConfig !== result.value.routeConfig) {\n    throw new Error('Cannot reattach ActivatedRouteSnapshot created from a different route');\n  }\n\n  if (curr.children.length !== result.children.length) {\n    throw new Error('Cannot reattach ActivatedRouteSnapshot with a different number of children');\n  }\n\n  result.value._futureSnapshot = curr.value;\n\n  for (var\n  /** @type {?} */\n  i = 0; i < curr.children.length; ++i) {\n    setFutureSnapshotsOfActivatedRoutes(curr.children[i], result.children[i]);\n  }\n}\n/**\n * @param {?} routeReuseStrategy\n * @param {?} curr\n * @param {?} prevState\n * @return {?}\n */\n\n\nfunction createOrReuseChildren(routeReuseStrategy, curr, prevState) {\n  return curr.children.map(function (child) {\n    var _iterator6 = _createForOfIteratorHelper(prevState.children),\n        _step6;\n\n    try {\n      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n        var p = _step6.value;\n\n        if (routeReuseStrategy.shouldReuseRoute(p.value.snapshot, child.value)) {\n          return createNode(routeReuseStrategy, child, p);\n        }\n      }\n    } catch (err) {\n      _iterator6.e(err);\n    } finally {\n      _iterator6.f();\n    }\n\n    return createNode(routeReuseStrategy, child);\n  });\n}\n/**\n * @param {?} c\n * @return {?}\n */\n\n\nfunction createActivatedRoute(c) {\n  return new ActivatedRoute(new BehaviorSubject(c.url), new BehaviorSubject(c.params), new BehaviorSubject(c.queryParams), new BehaviorSubject(c.fragment), new BehaviorSubject(c.data), c.outlet, c.component, c);\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @param {?} route\n * @param {?} urlTree\n * @param {?} commands\n * @param {?} queryParams\n * @param {?} fragment\n * @return {?}\n */\n\n\nfunction _createUrlTree(route, urlTree, commands, queryParams, fragment) {\n  if (commands.length === 0) {\n    return tree(urlTree.root, urlTree.root, urlTree, queryParams, fragment);\n  }\n\n  var\n  /** @type {?} */\n  nav = computeNavigation(commands);\n\n  if (nav.toRoot()) {\n    return tree(urlTree.root, new UrlSegmentGroup([], {}), urlTree, queryParams, fragment);\n  }\n\n  var\n  /** @type {?} */\n  startingPosition = findStartingPosition(nav, urlTree, route);\n  var\n  /** @type {?} */\n  segmentGroup = startingPosition.processChildren ? updateSegmentGroupChildren(startingPosition.segmentGroup, startingPosition.index, nav.commands) : updateSegmentGroup(startingPosition.segmentGroup, startingPosition.index, nav.commands);\n  return tree(startingPosition.segmentGroup, segmentGroup, urlTree, queryParams, fragment);\n}\n/**\n * @param {?} command\n * @return {?}\n */\n\n\nfunction isMatrixParams(command) {\n  return typeof command === 'object' && command != null && !command.outlets && !command.segmentPath;\n}\n/**\n * @param {?} oldSegmentGroup\n * @param {?} newSegmentGroup\n * @param {?} urlTree\n * @param {?} queryParams\n * @param {?} fragment\n * @return {?}\n */\n\n\nfunction tree(oldSegmentGroup, newSegmentGroup, urlTree, queryParams, fragment) {\n  var\n  /** @type {?} */\n  qp = {};\n\n  if (queryParams) {\n    forEach(queryParams, function (value, name) {\n      qp[name] = Array.isArray(value) ? value.map(function (v) {\n        return \"\".concat(v);\n      }) : \"\".concat(value);\n    });\n  }\n\n  if (urlTree.root === oldSegmentGroup) {\n    return new UrlTree(newSegmentGroup, qp, fragment);\n  }\n\n  return new UrlTree(replaceSegment(urlTree.root, oldSegmentGroup, newSegmentGroup), qp, fragment);\n}\n/**\n * @param {?} current\n * @param {?} oldSegment\n * @param {?} newSegment\n * @return {?}\n */\n\n\nfunction replaceSegment(current, oldSegment, newSegment) {\n  var\n  /** @type {?} */\n  children = {};\n  forEach(current.children, function (c, outletName) {\n    if (c === oldSegment) {\n      children[outletName] = newSegment;\n    } else {\n      children[outletName] = replaceSegment(c, oldSegment, newSegment);\n    }\n  });\n  return new UrlSegmentGroup(current.segments, children);\n}\n\nvar Navigation = /*#__PURE__*/function () {\n  /**\n   * @param {?} isAbsolute\n   * @param {?} numberOfDoubleDots\n   * @param {?} commands\n   */\n  function Navigation(isAbsolute, numberOfDoubleDots, commands) {\n    _classCallCheck(this, Navigation);\n\n    this.isAbsolute = isAbsolute;\n    this.numberOfDoubleDots = numberOfDoubleDots;\n    this.commands = commands;\n\n    if (isAbsolute && commands.length > 0 && isMatrixParams(commands[0])) {\n      throw new Error('Root segment cannot have matrix parameters');\n    }\n\n    var\n    /** @type {?} */\n    cmdWithOutlet = commands.find(function (c) {\n      return typeof c === 'object' && c != null && c.outlets;\n    });\n\n    if (cmdWithOutlet && cmdWithOutlet !== last$1(commands)) {\n      throw new Error('{outlets:{}} has to be the last command');\n    }\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(Navigation, [{\n    key: \"toRoot\",\n    value: function toRoot() {\n      return this.isAbsolute && this.commands.length === 1 && this.commands[0] == '/';\n    }\n  }]);\n\n  return Navigation;\n}();\n/**\n * Transforms commands to a normalized `Navigation`\n * @param {?} commands\n * @return {?}\n */\n\n\nfunction computeNavigation(commands) {\n  if (typeof commands[0] === 'string' && commands.length === 1 && commands[0] === '/') {\n    return new Navigation(true, 0, commands);\n  }\n\n  var\n  /** @type {?} */\n  numberOfDoubleDots = 0;\n  var\n  /** @type {?} */\n  isAbsolute = false;\n  var\n  /** @type {?} */\n  res = commands.reduce(function (res, cmd, cmdIdx) {\n    if (typeof cmd === 'object' && cmd != null) {\n      if (cmd.outlets) {\n        var\n        /** @type {?} */\n        outlets = {};\n        forEach(cmd.outlets, function (commands, name) {\n          outlets[name] = typeof commands === 'string' ? commands.split('/') : commands;\n        });\n        return [].concat(_toConsumableArray(res), [{\n          outlets: outlets\n        }]);\n      }\n\n      if (cmd.segmentPath) {\n        return [].concat(_toConsumableArray(res), [cmd.segmentPath]);\n      }\n    }\n\n    if (!(typeof cmd === 'string')) {\n      return [].concat(_toConsumableArray(res), [cmd]);\n    }\n\n    if (cmdIdx === 0) {\n      cmd.split('/').forEach(function (urlPart, partIndex) {\n        if (partIndex == 0 && urlPart === '.') {// skip './a'\n        } else if (partIndex == 0 && urlPart === '') {\n          //  '/a'\n          isAbsolute = true;\n        } else if (urlPart === '..') {\n          //  '../a'\n          numberOfDoubleDots++;\n        } else if (urlPart != '') {\n          res.push(urlPart);\n        }\n      });\n      return res;\n    }\n\n    return [].concat(_toConsumableArray(res), [cmd]);\n  }, []);\n  return new Navigation(isAbsolute, numberOfDoubleDots, res);\n}\n\nvar Position = /*#__PURE__*/_createClass(\n/**\n * @param {?} segmentGroup\n * @param {?} processChildren\n * @param {?} index\n */\nfunction Position(segmentGroup, processChildren, index) {\n  _classCallCheck(this, Position);\n\n  this.segmentGroup = segmentGroup;\n  this.processChildren = processChildren;\n  this.index = index;\n});\n/**\n * @param {?} nav\n * @param {?} tree\n * @param {?} route\n * @return {?}\n */\n\n\nfunction findStartingPosition(nav, tree, route) {\n  if (nav.isAbsolute) {\n    return new Position(tree.root, true, 0);\n  }\n\n  if (route.snapshot._lastPathIndex === -1) {\n    return new Position(route.snapshot._urlSegment, true, 0);\n  }\n\n  var\n  /** @type {?} */\n  modifier = isMatrixParams(nav.commands[0]) ? 0 : 1;\n  var\n  /** @type {?} */\n  index = route.snapshot._lastPathIndex + modifier;\n  return createPositionApplyingDoubleDots(route.snapshot._urlSegment, index, nav.numberOfDoubleDots);\n}\n/**\n * @param {?} group\n * @param {?} index\n * @param {?} numberOfDoubleDots\n * @return {?}\n */\n\n\nfunction createPositionApplyingDoubleDots(group, index, numberOfDoubleDots) {\n  var\n  /** @type {?} */\n  g = group;\n  var\n  /** @type {?} */\n  ci = index;\n  var\n  /** @type {?} */\n  dd = numberOfDoubleDots;\n\n  while (dd > ci) {\n    dd -= ci;\n    g =\n    /** @type {?} */\n    g.parent;\n\n    if (!g) {\n      throw new Error('Invalid number of \\'../\\'');\n    }\n\n    ci = g.segments.length;\n  }\n\n  return new Position(g, false, ci - dd);\n}\n/**\n * @param {?} command\n * @return {?}\n */\n\n\nfunction getPath(command) {\n  if (typeof command === 'object' && command != null && command.outlets) {\n    return command.outlets[PRIMARY_OUTLET];\n  }\n\n  return \"\".concat(command);\n}\n/**\n * @param {?} commands\n * @return {?}\n */\n\n\nfunction getOutlets(commands) {\n  if (!(typeof commands[0] === 'object')) return _defineProperty({}, PRIMARY_OUTLET, commands);\n  if (commands[0].outlets === undefined) return _defineProperty({}, PRIMARY_OUTLET, commands);\n  return commands[0].outlets;\n}\n/**\n * @param {?} segmentGroup\n * @param {?} startIndex\n * @param {?} commands\n * @return {?}\n */\n\n\nfunction updateSegmentGroup(segmentGroup, startIndex, commands) {\n  if (!segmentGroup) {\n    segmentGroup = new UrlSegmentGroup([], {});\n  }\n\n  if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n    return updateSegmentGroupChildren(segmentGroup, startIndex, commands);\n  }\n\n  var\n  /** @type {?} */\n  m = prefixedWith(segmentGroup, startIndex, commands);\n  var\n  /** @type {?} */\n  slicedCommands = commands.slice(m.commandIndex);\n\n  if (m.match && m.pathIndex < segmentGroup.segments.length) {\n    var\n    /** @type {?} */\n    g = new UrlSegmentGroup(segmentGroup.segments.slice(0, m.pathIndex), {});\n    g.children[PRIMARY_OUTLET] = new UrlSegmentGroup(segmentGroup.segments.slice(m.pathIndex), segmentGroup.children);\n    return updateSegmentGroupChildren(g, 0, slicedCommands);\n  } else if (m.match && slicedCommands.length === 0) {\n    return new UrlSegmentGroup(segmentGroup.segments, {});\n  } else if (m.match && !segmentGroup.hasChildren()) {\n    return createNewSegmentGroup(segmentGroup, startIndex, commands);\n  } else if (m.match) {\n    return updateSegmentGroupChildren(segmentGroup, 0, slicedCommands);\n  } else {\n    return createNewSegmentGroup(segmentGroup, startIndex, commands);\n  }\n}\n/**\n * @param {?} segmentGroup\n * @param {?} startIndex\n * @param {?} commands\n * @return {?}\n */\n\n\nfunction updateSegmentGroupChildren(segmentGroup, startIndex, commands) {\n  if (commands.length === 0) {\n    return new UrlSegmentGroup(segmentGroup.segments, {});\n  } else {\n    var\n    /** @type {?} */\n    outlets = getOutlets(commands);\n    var\n    /** @type {?} */\n    children = {};\n    forEach(outlets, function (commands, outlet) {\n      if (commands !== null) {\n        children[outlet] = updateSegmentGroup(segmentGroup.children[outlet], startIndex, commands);\n      }\n    });\n    forEach(segmentGroup.children, function (child, childOutlet) {\n      if (outlets[childOutlet] === undefined) {\n        children[childOutlet] = child;\n      }\n    });\n    return new UrlSegmentGroup(segmentGroup.segments, children);\n  }\n}\n/**\n * @param {?} segmentGroup\n * @param {?} startIndex\n * @param {?} commands\n * @return {?}\n */\n\n\nfunction prefixedWith(segmentGroup, startIndex, commands) {\n  var\n  /** @type {?} */\n  currentCommandIndex = 0;\n  var\n  /** @type {?} */\n  currentPathIndex = startIndex;\n  var\n  /** @type {?} */\n  noMatch = {\n    match: false,\n    pathIndex: 0,\n    commandIndex: 0\n  };\n\n  while (currentPathIndex < segmentGroup.segments.length) {\n    if (currentCommandIndex >= commands.length) return noMatch;\n    var\n    /** @type {?} */\n    path = segmentGroup.segments[currentPathIndex];\n    var\n    /** @type {?} */\n    curr = getPath(commands[currentCommandIndex]);\n    var\n    /** @type {?} */\n    next = currentCommandIndex < commands.length - 1 ? commands[currentCommandIndex + 1] : null;\n    if (currentPathIndex > 0 && curr === undefined) break;\n\n    if (curr && next && typeof next === 'object' && next.outlets === undefined) {\n      if (!compare(curr, next, path)) return noMatch;\n      currentCommandIndex += 2;\n    } else {\n      if (!compare(curr, {}, path)) return noMatch;\n      currentCommandIndex++;\n    }\n\n    currentPathIndex++;\n  }\n\n  return {\n    match: true,\n    pathIndex: currentPathIndex,\n    commandIndex: currentCommandIndex\n  };\n}\n/**\n * @param {?} segmentGroup\n * @param {?} startIndex\n * @param {?} commands\n * @return {?}\n */\n\n\nfunction createNewSegmentGroup(segmentGroup, startIndex, commands) {\n  var\n  /** @type {?} */\n  paths = segmentGroup.segments.slice(0, startIndex);\n  var\n  /** @type {?} */\n  i = 0;\n\n  while (i < commands.length) {\n    if (typeof commands[i] === 'object' && commands[i].outlets !== undefined) {\n      var\n      /** @type {?} */\n      children = createNewSegmentChildren(commands[i].outlets);\n      return new UrlSegmentGroup(paths, children);\n    } // if we start with an object literal, we need to reuse the path part from the segment\n\n\n    if (i === 0 && isMatrixParams(commands[0])) {\n      var\n      /** @type {?} */\n      p = segmentGroup.segments[startIndex];\n      paths.push(new UrlSegment(p.path, commands[0]));\n      i++;\n      continue;\n    }\n\n    var\n    /** @type {?} */\n    curr = getPath(commands[i]);\n    var\n    /** @type {?} */\n    next = i < commands.length - 1 ? commands[i + 1] : null;\n\n    if (curr && next && isMatrixParams(next)) {\n      paths.push(new UrlSegment(curr, stringify(next)));\n      i += 2;\n    } else {\n      paths.push(new UrlSegment(curr, {}));\n      i++;\n    }\n  }\n\n  return new UrlSegmentGroup(paths, {});\n}\n/**\n * @param {?} outlets\n * @return {?}\n */\n\n\nfunction createNewSegmentChildren(outlets) {\n  var\n  /** @type {?} */\n  children = {};\n  forEach(outlets, function (commands, outlet) {\n    if (commands !== null) {\n      children[outlet] = createNewSegmentGroup(new UrlSegmentGroup([], {}), 0, commands);\n    }\n  });\n  return children;\n}\n/**\n * @param {?} params\n * @return {?}\n */\n\n\nfunction stringify(params) {\n  var\n  /** @type {?} */\n  res = {};\n  forEach(params, function (v, k) {\n    return res[k] = \"\".concat(v);\n  });\n  return res;\n}\n/**\n * @param {?} path\n * @param {?} params\n * @param {?} segment\n * @return {?}\n */\n\n\nfunction compare(path, params, segment) {\n  return path == segment.path && shallowEqual(params, segment.parameters);\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar CanActivate = /*#__PURE__*/_createClass(\n/**\n * @param {?} path\n */\nfunction CanActivate(path) {\n  _classCallCheck(this, CanActivate);\n\n  this.path = path;\n  this.route = this.path[this.path.length - 1];\n});\n\nvar CanDeactivate = /*#__PURE__*/_createClass(\n/**\n * @param {?} component\n * @param {?} route\n */\nfunction CanDeactivate(component, route) {\n  _classCallCheck(this, CanDeactivate);\n\n  this.component = component;\n  this.route = route;\n});\n/**\n * This class bundles the actions involved in preactivation of a route.\n */\n\n\nvar PreActivation = /*#__PURE__*/function () {\n  /**\n   * @param {?} future\n   * @param {?} curr\n   * @param {?} moduleInjector\n   * @param {?=} forwardEvent\n   */\n  function PreActivation(future, curr, moduleInjector, forwardEvent) {\n    _classCallCheck(this, PreActivation);\n\n    this.future = future;\n    this.curr = curr;\n    this.moduleInjector = moduleInjector;\n    this.forwardEvent = forwardEvent;\n    this.canActivateChecks = [];\n    this.canDeactivateChecks = [];\n  }\n  /**\n   * @param {?} parentContexts\n   * @return {?}\n   */\n\n\n  _createClass(PreActivation, [{\n    key: \"initialize\",\n    value: function initialize(parentContexts) {\n      var\n      /** @type {?} */\n      futureRoot = this.future._root;\n      var\n      /** @type {?} */\n      currRoot = this.curr ? this.curr._root : null;\n      this.setupChildRouteGuards(futureRoot, currRoot, parentContexts, [futureRoot.value]);\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"checkGuards\",\n    value: function checkGuards() {\n      var _this22 = this;\n\n      if (!this.isDeactivating() && !this.isActivating()) {\n        return of(true);\n      }\n\n      var\n      /** @type {?} */\n      canDeactivate$ = this.runCanDeactivateChecks();\n      return mergeMap.call(canDeactivate$, function (canDeactivate) {\n        return canDeactivate ? _this22.runCanActivateChecks() : of(false);\n      });\n    }\n    /**\n     * @param {?} paramsInheritanceStrategy\n     * @return {?}\n     */\n\n  }, {\n    key: \"resolveData\",\n    value: function resolveData(paramsInheritanceStrategy) {\n      var _this23 = this;\n\n      if (!this.isActivating()) return of(null);\n      var\n      /** @type {?} */\n      checks$ = from(this.canActivateChecks);\n      var\n      /** @type {?} */\n      runningChecks$ = concatMap.call(checks$, function (check) {\n        return _this23.runResolve(check.route, paramsInheritanceStrategy);\n      });\n      return reduce.call(runningChecks$, function (_, __) {\n        return _;\n      });\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"isDeactivating\",\n    value: function isDeactivating() {\n      return this.canDeactivateChecks.length !== 0;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"isActivating\",\n    value: function isActivating() {\n      return this.canActivateChecks.length !== 0;\n    }\n    /**\n     * Iterates over child routes and calls recursive `setupRouteGuards` to get `this` instance in\n     * proper state to run `checkGuards()` method.\n     * @param {?} futureNode\n     * @param {?} currNode\n     * @param {?} contexts\n     * @param {?} futurePath\n     * @return {?}\n     */\n\n  }, {\n    key: \"setupChildRouteGuards\",\n    value: function setupChildRouteGuards(futureNode, currNode, contexts, futurePath) {\n      var _this24 = this;\n\n      var\n      /** @type {?} */\n      prevChildren = nodeChildrenAsMap(currNode); // Process the children of the future route\n\n      futureNode.children.forEach(function (c) {\n        _this24.setupRouteGuards(c, prevChildren[c.value.outlet], contexts, futurePath.concat([c.value]));\n\n        delete prevChildren[c.value.outlet];\n      }); // Process any children left from the current route (not active for the future route)\n\n      forEach(prevChildren, function (v, k) {\n        return _this24.deactivateRouteAndItsChildren(v,\n        /** @type {?} */\n        contexts.getContext(k));\n      });\n    }\n    /**\n     * Iterates over child routes and calls recursive `setupRouteGuards` to get `this` instance in\n     * proper state to run `checkGuards()` method.\n     * @param {?} futureNode\n     * @param {?} currNode\n     * @param {?} parentContexts\n     * @param {?} futurePath\n     * @return {?}\n     */\n\n  }, {\n    key: \"setupRouteGuards\",\n    value: function setupRouteGuards(futureNode, currNode, parentContexts, futurePath) {\n      var\n      /** @type {?} */\n      future = futureNode.value;\n      var\n      /** @type {?} */\n      curr = currNode ? currNode.value : null;\n      var\n      /** @type {?} */\n      context = parentContexts ? parentContexts.getContext(futureNode.value.outlet) : null; // reusing the node\n\n      if (curr && future.routeConfig === curr.routeConfig) {\n        var\n        /** @type {?} */\n        shouldRunGuardsAndResolvers = this.shouldRunGuardsAndResolvers(curr, future,\n        /** @type {?} */\n        future.routeConfig.runGuardsAndResolvers);\n\n        if (shouldRunGuardsAndResolvers) {\n          this.canActivateChecks.push(new CanActivate(futurePath));\n        } else {\n          // we need to set the data\n          future.data = curr.data;\n          future._resolvedData = curr._resolvedData;\n        } // If we have a component, we need to go through an outlet.\n\n\n        if (future.component) {\n          this.setupChildRouteGuards(futureNode, currNode, context ? context.children : null, futurePath); // if we have a componentless route, we recurse but keep the same outlet map.\n        } else {\n          this.setupChildRouteGuards(futureNode, currNode, parentContexts, futurePath);\n        }\n\n        if (shouldRunGuardsAndResolvers) {\n          var\n          /** @type {?} */\n          outlet =\n          /** @type {?} */\n\n          /** @type {?} */\n          context.outlet;\n          this.canDeactivateChecks.push(new CanDeactivate(outlet.component, curr));\n        }\n      } else {\n        if (curr) {\n          this.deactivateRouteAndItsChildren(currNode, context);\n        }\n\n        this.canActivateChecks.push(new CanActivate(futurePath)); // If we have a component, we need to go through an outlet.\n\n        if (future.component) {\n          this.setupChildRouteGuards(futureNode, null, context ? context.children : null, futurePath); // if we have a componentless route, we recurse but keep the same outlet map.\n        } else {\n          this.setupChildRouteGuards(futureNode, null, parentContexts, futurePath);\n        }\n      }\n    }\n    /**\n     * @param {?} curr\n     * @param {?} future\n     * @param {?} mode\n     * @return {?}\n     */\n\n  }, {\n    key: \"shouldRunGuardsAndResolvers\",\n    value: function shouldRunGuardsAndResolvers(curr, future, mode) {\n      switch (mode) {\n        case 'always':\n          return true;\n\n        case 'paramsOrQueryParamsChange':\n          return !equalParamsAndUrlSegments(curr, future) || !shallowEqual(curr.queryParams, future.queryParams);\n\n        case 'paramsChange':\n        default:\n          return !equalParamsAndUrlSegments(curr, future);\n      }\n    }\n    /**\n     * @param {?} route\n     * @param {?} context\n     * @return {?}\n     */\n\n  }, {\n    key: \"deactivateRouteAndItsChildren\",\n    value: function deactivateRouteAndItsChildren(route, context) {\n      var _this25 = this;\n\n      var\n      /** @type {?} */\n      children = nodeChildrenAsMap(route);\n      var\n      /** @type {?} */\n      r = route.value;\n      forEach(children, function (node, childName) {\n        if (!r.component) {\n          _this25.deactivateRouteAndItsChildren(node, context);\n        } else if (context) {\n          _this25.deactivateRouteAndItsChildren(node, context.children.getContext(childName));\n        } else {\n          _this25.deactivateRouteAndItsChildren(node, null);\n        }\n      });\n\n      if (!r.component) {\n        this.canDeactivateChecks.push(new CanDeactivate(null, r));\n      } else if (context && context.outlet && context.outlet.isActivated) {\n        this.canDeactivateChecks.push(new CanDeactivate(context.outlet.component, r));\n      } else {\n        this.canDeactivateChecks.push(new CanDeactivate(null, r));\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"runCanDeactivateChecks\",\n    value: function runCanDeactivateChecks() {\n      var _this26 = this;\n\n      var\n      /** @type {?} */\n      checks$ = from(this.canDeactivateChecks);\n      var\n      /** @type {?} */\n      runningChecks$ = mergeMap.call(checks$, function (check) {\n        return _this26.runCanDeactivate(check.component, check.route);\n      });\n      return every.call(runningChecks$, function (result) {\n        return result === true;\n      });\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"runCanActivateChecks\",\n    value: function runCanActivateChecks() {\n      var _this27 = this;\n\n      var\n      /** @type {?} */\n      checks$ = from(this.canActivateChecks);\n      var\n      /** @type {?} */\n      runningChecks$ = concatMap.call(checks$, function (check) {\n        return andObservables(from([_this27.fireChildActivationStart(check.route.parent), _this27.fireActivationStart(check.route), _this27.runCanActivateChild(check.path), _this27.runCanActivate(check.route)]));\n      });\n      return every.call(runningChecks$, function (result) {\n        return result === true;\n      }); // this.fireChildActivationStart(check.path),\n    }\n    /**\n     * This should fire off `ActivationStart` events for each route being activated at this\n     * level.\n     * In other words, if you're activating `a` and `b` below, `path` will contain the\n     * `ActivatedRouteSnapshot`s for both and we will fire `ActivationStart` for both. Always\n     * return\n     * `true` so checks continue to run.\n     * @param {?} snapshot\n     * @return {?}\n     */\n\n  }, {\n    key: \"fireActivationStart\",\n    value: function fireActivationStart(snapshot) {\n      if (snapshot !== null && this.forwardEvent) {\n        this.forwardEvent(new ActivationStart(snapshot));\n      }\n\n      return of(true);\n    }\n    /**\n     * This should fire off `ChildActivationStart` events for each route being activated at this\n     * level.\n     * In other words, if you're activating `a` and `b` below, `path` will contain the\n     * `ActivatedRouteSnapshot`s for both and we will fire `ChildActivationStart` for both. Always\n     * return\n     * `true` so checks continue to run.\n     * @param {?} snapshot\n     * @return {?}\n     */\n\n  }, {\n    key: \"fireChildActivationStart\",\n    value: function fireChildActivationStart(snapshot) {\n      if (snapshot !== null && this.forwardEvent) {\n        this.forwardEvent(new ChildActivationStart(snapshot));\n      }\n\n      return of(true);\n    }\n    /**\n     * @param {?} future\n     * @return {?}\n     */\n\n  }, {\n    key: \"runCanActivate\",\n    value: function runCanActivate(future) {\n      var _this28 = this;\n\n      var\n      /** @type {?} */\n      canActivate = future.routeConfig ? future.routeConfig.canActivate : null;\n      if (!canActivate || canActivate.length === 0) return of(true);\n      var\n      /** @type {?} */\n      obs = map.call(from(canActivate), function (c) {\n        var\n        /** @type {?} */\n        guard = _this28.getToken(c, future);\n\n        var\n        /** @type {?} */\n        observable;\n\n        if (guard.canActivate) {\n          observable = wrapIntoObservable(guard.canActivate(future, _this28.future));\n        } else {\n          observable = wrapIntoObservable(guard(future, _this28.future));\n        }\n\n        return first.call(observable);\n      });\n      return andObservables(obs);\n    }\n    /**\n     * @param {?} path\n     * @return {?}\n     */\n\n  }, {\n    key: \"runCanActivateChild\",\n    value: function runCanActivateChild(path) {\n      var _this29 = this;\n\n      var\n      /** @type {?} */\n      future = path[path.length - 1];\n      var\n      /** @type {?} */\n      canActivateChildGuards = path.slice(0, path.length - 1).reverse().map(function (p) {\n        return _this29.extractCanActivateChild(p);\n      }).filter(function (_) {\n        return _ !== null;\n      });\n      return andObservables(map.call(from(canActivateChildGuards), function (d) {\n        var\n        /** @type {?} */\n        obs = map.call(from(d.guards), function (c) {\n          var\n          /** @type {?} */\n          guard = _this29.getToken(c, d.node);\n\n          var\n          /** @type {?} */\n          observable;\n\n          if (guard.canActivateChild) {\n            observable = wrapIntoObservable(guard.canActivateChild(future, _this29.future));\n          } else {\n            observable = wrapIntoObservable(guard(future, _this29.future));\n          }\n\n          return first.call(observable);\n        });\n        return andObservables(obs);\n      }));\n    }\n    /**\n     * @param {?} p\n     * @return {?}\n     */\n\n  }, {\n    key: \"extractCanActivateChild\",\n    value: function extractCanActivateChild(p) {\n      var\n      /** @type {?} */\n      canActivateChild = p.routeConfig ? p.routeConfig.canActivateChild : null;\n      if (!canActivateChild || canActivateChild.length === 0) return null;\n      return {\n        node: p,\n        guards: canActivateChild\n      };\n    }\n    /**\n     * @param {?} component\n     * @param {?} curr\n     * @return {?}\n     */\n\n  }, {\n    key: \"runCanDeactivate\",\n    value: function runCanDeactivate(component, curr) {\n      var _this30 = this;\n\n      var\n      /** @type {?} */\n      canDeactivate = curr && curr.routeConfig ? curr.routeConfig.canDeactivate : null;\n      if (!canDeactivate || canDeactivate.length === 0) return of(true);\n      var\n      /** @type {?} */\n      canDeactivate$ = mergeMap.call(from(canDeactivate), function (c) {\n        var\n        /** @type {?} */\n        guard = _this30.getToken(c, curr);\n\n        var\n        /** @type {?} */\n        observable;\n\n        if (guard.canDeactivate) {\n          observable = wrapIntoObservable(guard.canDeactivate(component, curr, _this30.curr, _this30.future));\n        } else {\n          observable = wrapIntoObservable(guard(component, curr, _this30.curr, _this30.future));\n        }\n\n        return first.call(observable);\n      });\n      return every.call(canDeactivate$, function (result) {\n        return result === true;\n      });\n    }\n    /**\n     * @param {?} future\n     * @param {?} paramsInheritanceStrategy\n     * @return {?}\n     */\n\n  }, {\n    key: \"runResolve\",\n    value: function runResolve(future, paramsInheritanceStrategy) {\n      var\n      /** @type {?} */\n      resolve = future._resolve;\n      return map.call(this.resolveNode(resolve, future), function (resolvedData) {\n        future._resolvedData = resolvedData;\n        future.data = Object.assign({}, future.data, inheritedParamsDataResolve(future, paramsInheritanceStrategy).resolve);\n        return null;\n      });\n    }\n    /**\n     * @param {?} resolve\n     * @param {?} future\n     * @return {?}\n     */\n\n  }, {\n    key: \"resolveNode\",\n    value: function resolveNode(resolve, future) {\n      var _this31 = this;\n\n      var\n      /** @type {?} */\n      keys = Object.keys(resolve);\n\n      if (keys.length === 0) {\n        return of({});\n      }\n\n      if (keys.length === 1) {\n        var\n        /** @type {?} */\n        key = keys[0];\n        return map.call(this.getResolver(resolve[key], future), function (value) {\n          return _defineProperty({}, key, value);\n        });\n      }\n\n      var\n      /** @type {?} */\n      data = {};\n      var\n      /** @type {?} */\n      runningResolvers$ = mergeMap.call(from(keys), function (key) {\n        return map.call(_this31.getResolver(resolve[key], future), function (value) {\n          data[key] = value;\n          return value;\n        });\n      });\n      return map.call(last.call(runningResolvers$), function () {\n        return data;\n      });\n    }\n    /**\n     * @param {?} injectionToken\n     * @param {?} future\n     * @return {?}\n     */\n\n  }, {\n    key: \"getResolver\",\n    value: function getResolver(injectionToken, future) {\n      var\n      /** @type {?} */\n      resolver = this.getToken(injectionToken, future);\n      return resolver.resolve ? wrapIntoObservable(resolver.resolve(future, this.future)) : wrapIntoObservable(resolver(future, this.future));\n    }\n    /**\n     * @param {?} token\n     * @param {?} snapshot\n     * @return {?}\n     */\n\n  }, {\n    key: \"getToken\",\n    value: function getToken(token, snapshot) {\n      var\n      /** @type {?} */\n      config = closestLoadedConfig(snapshot);\n      var\n      /** @type {?} */\n      injector = config ? config.module.injector : this.moduleInjector;\n      return injector.get(token);\n    }\n  }]);\n\n  return PreActivation;\n}();\n/**\n * @param {?} snapshot\n * @return {?}\n */\n\n\nfunction closestLoadedConfig(snapshot) {\n  if (!snapshot) return null;\n\n  for (var\n  /** @type {?} */\n  s = snapshot.parent; s; s = s.parent) {\n    var\n    /** @type {?} */\n    route = s.routeConfig;\n    if (route && route._loadedConfig) return route._loadedConfig;\n  }\n\n  return null;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar NoMatch$1 = /*#__PURE__*/_createClass(function NoMatch$1() {\n  _classCallCheck(this, NoMatch$1);\n});\n/**\n * @param {?} rootComponentType\n * @param {?} config\n * @param {?} urlTree\n * @param {?} url\n * @param {?=} paramsInheritanceStrategy\n * @return {?}\n */\n\n\nfunction recognize(rootComponentType, config, urlTree, url) {\n  var paramsInheritanceStrategy = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'emptyOnly';\n  return new Recognizer(rootComponentType, config, urlTree, url, paramsInheritanceStrategy).recognize();\n}\n\nvar Recognizer = /*#__PURE__*/function () {\n  /**\n   * @param {?} rootComponentType\n   * @param {?} config\n   * @param {?} urlTree\n   * @param {?} url\n   * @param {?} paramsInheritanceStrategy\n   */\n  function Recognizer(rootComponentType, config, urlTree, url, paramsInheritanceStrategy) {\n    _classCallCheck(this, Recognizer);\n\n    this.rootComponentType = rootComponentType;\n    this.config = config;\n    this.urlTree = urlTree;\n    this.url = url;\n    this.paramsInheritanceStrategy = paramsInheritanceStrategy;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(Recognizer, [{\n    key: \"recognize\",\n    value: function recognize() {\n      try {\n        var\n        /** @type {?} */\n        rootSegmentGroup = split$1(this.urlTree.root, [], [], this.config).segmentGroup;\n        var\n        /** @type {?} */\n        children = this.processSegmentGroup(this.config, rootSegmentGroup, PRIMARY_OUTLET);\n        var\n        /** @type {?} */\n        root = new ActivatedRouteSnapshot([], Object.freeze({}), Object.freeze(this.urlTree.queryParams),\n        /** @type {?} */\n        this.urlTree.fragment, {}, PRIMARY_OUTLET, this.rootComponentType, null, this.urlTree.root, -1, {});\n        var\n        /** @type {?} */\n        rootNode = new TreeNode(root, children);\n        var\n        /** @type {?} */\n        routeState = new RouterStateSnapshot(this.url, rootNode);\n        this.inheritParamsAndData(routeState._root);\n        return of(routeState);\n      } catch (\n      /** @type {?} */\n      e) {\n        return new Observable(function (obs) {\n          return obs.error(e);\n        });\n      }\n    }\n    /**\n     * @param {?} routeNode\n     * @return {?}\n     */\n\n  }, {\n    key: \"inheritParamsAndData\",\n    value: function inheritParamsAndData(routeNode) {\n      var _this32 = this;\n\n      var\n      /** @type {?} */\n      route = routeNode.value;\n      var\n      /** @type {?} */\n      i = inheritedParamsDataResolve(route, this.paramsInheritanceStrategy);\n      route.params = Object.freeze(i.params);\n      route.data = Object.freeze(i.data);\n      routeNode.children.forEach(function (n) {\n        return _this32.inheritParamsAndData(n);\n      });\n    }\n    /**\n     * @param {?} config\n     * @param {?} segmentGroup\n     * @param {?} outlet\n     * @return {?}\n     */\n\n  }, {\n    key: \"processSegmentGroup\",\n    value: function processSegmentGroup(config, segmentGroup, outlet) {\n      if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n        return this.processChildren(config, segmentGroup);\n      }\n\n      return this.processSegment(config, segmentGroup, segmentGroup.segments, outlet);\n    }\n    /**\n     * @param {?} config\n     * @param {?} segmentGroup\n     * @return {?}\n     */\n\n  }, {\n    key: \"processChildren\",\n    value: function processChildren(config, segmentGroup) {\n      var _this33 = this;\n\n      var\n      /** @type {?} */\n      children = mapChildrenIntoArray(segmentGroup, function (child, childOutlet) {\n        return _this33.processSegmentGroup(config, child, childOutlet);\n      });\n      checkOutletNameUniqueness(children);\n      sortActivatedRouteSnapshots(children);\n      return children;\n    }\n    /**\n     * @param {?} config\n     * @param {?} segmentGroup\n     * @param {?} segments\n     * @param {?} outlet\n     * @return {?}\n     */\n\n  }, {\n    key: \"processSegment\",\n    value: function processSegment(config, segmentGroup, segments, outlet) {\n      var _iterator7 = _createForOfIteratorHelper(config),\n          _step7;\n\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var r = _step7.value;\n\n          try {\n            return this.processSegmentAgainstRoute(r, segmentGroup, segments, outlet);\n          } catch (\n          /** @type {?} */\n          e) {\n            if (!(e instanceof NoMatch$1)) throw e;\n          }\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n\n      if (this.noLeftoversInUrl(segmentGroup, segments, outlet)) {\n        return [];\n      }\n\n      throw new NoMatch$1();\n    }\n    /**\n     * @param {?} segmentGroup\n     * @param {?} segments\n     * @param {?} outlet\n     * @return {?}\n     */\n\n  }, {\n    key: \"noLeftoversInUrl\",\n    value: function noLeftoversInUrl(segmentGroup, segments, outlet) {\n      return segments.length === 0 && !segmentGroup.children[outlet];\n    }\n    /**\n     * @param {?} route\n     * @param {?} rawSegment\n     * @param {?} segments\n     * @param {?} outlet\n     * @return {?}\n     */\n\n  }, {\n    key: \"processSegmentAgainstRoute\",\n    value: function processSegmentAgainstRoute(route, rawSegment, segments, outlet) {\n      if (route.redirectTo) throw new NoMatch$1();\n      if ((route.outlet || PRIMARY_OUTLET) !== outlet) throw new NoMatch$1();\n      var\n      /** @type {?} */\n      snapshot;\n      var\n      /** @type {?} */\n      consumedSegments = [];\n      var\n      /** @type {?} */\n      rawSlicedSegments = [];\n\n      if (route.path === '**') {\n        var\n        /** @type {?} */\n        params = segments.length > 0 ?\n        /** @type {?} */\n        last$1(segments).parameters : {};\n        snapshot = new ActivatedRouteSnapshot(segments, params, Object.freeze(this.urlTree.queryParams),\n        /** @type {?} */\n        this.urlTree.fragment, getData(route), outlet,\n        /** @type {?} */\n        route.component, route, getSourceSegmentGroup(rawSegment), getPathIndexShift(rawSegment) + segments.length, getResolve(route));\n      } else {\n        var\n        /** @type {?} */\n        result = match$1(rawSegment, route, segments);\n        consumedSegments = result.consumedSegments;\n        rawSlicedSegments = segments.slice(result.lastChild);\n        snapshot = new ActivatedRouteSnapshot(consumedSegments, result.parameters, Object.freeze(this.urlTree.queryParams),\n        /** @type {?} */\n        this.urlTree.fragment, getData(route), outlet,\n        /** @type {?} */\n        route.component, route, getSourceSegmentGroup(rawSegment), getPathIndexShift(rawSegment) + consumedSegments.length, getResolve(route));\n      }\n\n      var\n      /** @type {?} */\n      childConfig = getChildConfig(route);\n\n      var _split$ = split$1(rawSegment, consumedSegments, rawSlicedSegments, childConfig),\n          segmentGroup = _split$.segmentGroup,\n          slicedSegments = _split$.slicedSegments;\n\n      if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {\n        var\n        /** @type {?} */\n        _children3 = this.processChildren(childConfig, segmentGroup);\n\n        return [new TreeNode(snapshot, _children3)];\n      }\n\n      if (childConfig.length === 0 && slicedSegments.length === 0) {\n        return [new TreeNode(snapshot, [])];\n      }\n\n      var\n      /** @type {?} */\n      children = this.processSegment(childConfig, segmentGroup, slicedSegments, PRIMARY_OUTLET);\n      return [new TreeNode(snapshot, children)];\n    }\n  }]);\n\n  return Recognizer;\n}();\n/**\n * @param {?} nodes\n * @return {?}\n */\n\n\nfunction sortActivatedRouteSnapshots(nodes) {\n  nodes.sort(function (a, b) {\n    if (a.value.outlet === PRIMARY_OUTLET) return -1;\n    if (b.value.outlet === PRIMARY_OUTLET) return 1;\n    return a.value.outlet.localeCompare(b.value.outlet);\n  });\n}\n/**\n * @param {?} route\n * @return {?}\n */\n\n\nfunction getChildConfig(route) {\n  if (route.children) {\n    return route.children;\n  }\n\n  if (route.loadChildren) {\n    return (\n      /** @type {?} */\n      route._loadedConfig.routes\n    );\n  }\n\n  return [];\n}\n/**\n * @param {?} segmentGroup\n * @param {?} route\n * @param {?} segments\n * @return {?}\n */\n\n\nfunction match$1(segmentGroup, route, segments) {\n  if (route.path === '') {\n    if (route.pathMatch === 'full' && (segmentGroup.hasChildren() || segments.length > 0)) {\n      throw new NoMatch$1();\n    }\n\n    return {\n      consumedSegments: [],\n      lastChild: 0,\n      parameters: {}\n    };\n  }\n\n  var\n  /** @type {?} */\n  matcher = route.matcher || defaultUrlMatcher;\n  var\n  /** @type {?} */\n  res = matcher(segments, segmentGroup, route);\n  if (!res) throw new NoMatch$1();\n  var\n  /** @type {?} */\n  posParams = {};\n  forEach(\n  /** @type {?} */\n  res.posParams, function (v, k) {\n    posParams[k] = v.path;\n  });\n  var\n  /** @type {?} */\n  parameters = res.consumed.length > 0 ? Object.assign({}, posParams, res.consumed[res.consumed.length - 1].parameters) : posParams;\n  return {\n    consumedSegments: res.consumed,\n    lastChild: res.consumed.length,\n    parameters: parameters\n  };\n}\n/**\n * @param {?} nodes\n * @return {?}\n */\n\n\nfunction checkOutletNameUniqueness(nodes) {\n  var\n  /** @type {?} */\n  names = {};\n  nodes.forEach(function (n) {\n    var\n    /** @type {?} */\n    routeWithSameOutletName = names[n.value.outlet];\n\n    if (routeWithSameOutletName) {\n      var\n      /** @type {?} */\n      p = routeWithSameOutletName.url.map(function (s) {\n        return s.toString();\n      }).join('/');\n      var\n      /** @type {?} */\n      c = n.value.url.map(function (s) {\n        return s.toString();\n      }).join('/');\n      throw new Error(\"Two segments cannot have the same outlet name: '\".concat(p, \"' and '\").concat(c, \"'.\"));\n    }\n\n    names[n.value.outlet] = n.value;\n  });\n}\n/**\n * @param {?} segmentGroup\n * @return {?}\n */\n\n\nfunction getSourceSegmentGroup(segmentGroup) {\n  var\n  /** @type {?} */\n  s = segmentGroup;\n\n  while (s._sourceSegment) {\n    s = s._sourceSegment;\n  }\n\n  return s;\n}\n/**\n * @param {?} segmentGroup\n * @return {?}\n */\n\n\nfunction getPathIndexShift(segmentGroup) {\n  var\n  /** @type {?} */\n  s = segmentGroup;\n  var\n  /** @type {?} */\n  res = s._segmentIndexShift ? s._segmentIndexShift : 0;\n\n  while (s._sourceSegment) {\n    s = s._sourceSegment;\n    res += s._segmentIndexShift ? s._segmentIndexShift : 0;\n  }\n\n  return res - 1;\n}\n/**\n * @param {?} segmentGroup\n * @param {?} consumedSegments\n * @param {?} slicedSegments\n * @param {?} config\n * @return {?}\n */\n\n\nfunction split$1(segmentGroup, consumedSegments, slicedSegments, config) {\n  if (slicedSegments.length > 0 && containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, config)) {\n    var\n    /** @type {?} */\n    _s2 = new UrlSegmentGroup(consumedSegments, createChildrenForEmptyPaths(segmentGroup, consumedSegments, config, new UrlSegmentGroup(slicedSegments, segmentGroup.children)));\n\n    _s2._sourceSegment = segmentGroup;\n    _s2._segmentIndexShift = consumedSegments.length;\n    return {\n      segmentGroup: _s2,\n      slicedSegments: []\n    };\n  }\n\n  if (slicedSegments.length === 0 && containsEmptyPathMatches(segmentGroup, slicedSegments, config)) {\n    var\n    /** @type {?} */\n    _s3 = new UrlSegmentGroup(segmentGroup.segments, addEmptyPathsToChildrenIfNeeded(segmentGroup, slicedSegments, config, segmentGroup.children));\n\n    _s3._sourceSegment = segmentGroup;\n    _s3._segmentIndexShift = consumedSegments.length;\n    return {\n      segmentGroup: _s3,\n      slicedSegments: slicedSegments\n    };\n  }\n\n  var\n  /** @type {?} */\n  s = new UrlSegmentGroup(segmentGroup.segments, segmentGroup.children);\n  s._sourceSegment = segmentGroup;\n  s._segmentIndexShift = consumedSegments.length;\n  return {\n    segmentGroup: s,\n    slicedSegments: slicedSegments\n  };\n}\n/**\n * @param {?} segmentGroup\n * @param {?} slicedSegments\n * @param {?} routes\n * @param {?} children\n * @return {?}\n */\n\n\nfunction addEmptyPathsToChildrenIfNeeded(segmentGroup, slicedSegments, routes, children) {\n  var\n  /** @type {?} */\n  res = {};\n\n  var _iterator8 = _createForOfIteratorHelper(routes),\n      _step8;\n\n  try {\n    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n      var r = _step8.value;\n\n      if (emptyPathMatch(segmentGroup, slicedSegments, r) && !children[getOutlet$1(r)]) {\n        var\n        /** @type {?} */\n        s = new UrlSegmentGroup([], {});\n        s._sourceSegment = segmentGroup;\n        s._segmentIndexShift = segmentGroup.segments.length;\n        res[getOutlet$1(r)] = s;\n      }\n    }\n  } catch (err) {\n    _iterator8.e(err);\n  } finally {\n    _iterator8.f();\n  }\n\n  return Object.assign({}, children, res);\n}\n/**\n * @param {?} segmentGroup\n * @param {?} consumedSegments\n * @param {?} routes\n * @param {?} primarySegment\n * @return {?}\n */\n\n\nfunction createChildrenForEmptyPaths(segmentGroup, consumedSegments, routes, primarySegment) {\n  var\n  /** @type {?} */\n  res = {};\n  res[PRIMARY_OUTLET] = primarySegment;\n  primarySegment._sourceSegment = segmentGroup;\n  primarySegment._segmentIndexShift = consumedSegments.length;\n\n  var _iterator9 = _createForOfIteratorHelper(routes),\n      _step9;\n\n  try {\n    for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n      var r = _step9.value;\n\n      if (r.path === '' && getOutlet$1(r) !== PRIMARY_OUTLET) {\n        var\n        /** @type {?} */\n        s = new UrlSegmentGroup([], {});\n        s._sourceSegment = segmentGroup;\n        s._segmentIndexShift = consumedSegments.length;\n        res[getOutlet$1(r)] = s;\n      }\n    }\n  } catch (err) {\n    _iterator9.e(err);\n  } finally {\n    _iterator9.f();\n  }\n\n  return res;\n}\n/**\n * @param {?} segmentGroup\n * @param {?} slicedSegments\n * @param {?} routes\n * @return {?}\n */\n\n\nfunction containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, routes) {\n  return routes.some(function (r) {\n    return emptyPathMatch(segmentGroup, slicedSegments, r) && getOutlet$1(r) !== PRIMARY_OUTLET;\n  });\n}\n/**\n * @param {?} segmentGroup\n * @param {?} slicedSegments\n * @param {?} routes\n * @return {?}\n */\n\n\nfunction containsEmptyPathMatches(segmentGroup, slicedSegments, routes) {\n  return routes.some(function (r) {\n    return emptyPathMatch(segmentGroup, slicedSegments, r);\n  });\n}\n/**\n * @param {?} segmentGroup\n * @param {?} slicedSegments\n * @param {?} r\n * @return {?}\n */\n\n\nfunction emptyPathMatch(segmentGroup, slicedSegments, r) {\n  if ((segmentGroup.hasChildren() || slicedSegments.length > 0) && r.pathMatch === 'full') {\n    return false;\n  }\n\n  return r.path === '' && r.redirectTo === undefined;\n}\n/**\n * @param {?} route\n * @return {?}\n */\n\n\nfunction getOutlet$1(route) {\n  return route.outlet || PRIMARY_OUTLET;\n}\n/**\n * @param {?} route\n * @return {?}\n */\n\n\nfunction getData(route) {\n  return route.data || {};\n}\n/**\n * @param {?} route\n * @return {?}\n */\n\n\nfunction getResolve(route) {\n  return route.resolve || {};\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * \\@whatItDoes Provides a way to customize when activated routes get reused.\n *\n * \\@experimental\n * @abstract\n */\n\n\nvar RouteReuseStrategy = /*#__PURE__*/_createClass(function RouteReuseStrategy() {\n  _classCallCheck(this, RouteReuseStrategy);\n});\n/**\n * Does not detach any subtrees. Reuses routes as long as their route config is the same.\n */\n\n\nvar DefaultRouteReuseStrategy = /*#__PURE__*/function () {\n  function DefaultRouteReuseStrategy() {\n    _classCallCheck(this, DefaultRouteReuseStrategy);\n  }\n\n  _createClass(DefaultRouteReuseStrategy, [{\n    key: \"shouldDetach\",\n    value:\n    /**\n     * @param {?} route\n     * @return {?}\n     */\n    function shouldDetach(route) {\n      return false;\n    }\n    /**\n     * @param {?} route\n     * @param {?} detachedTree\n     * @return {?}\n     */\n\n  }, {\n    key: \"store\",\n    value: function store(route, detachedTree) {}\n    /**\n     * @param {?} route\n     * @return {?}\n     */\n\n  }, {\n    key: \"shouldAttach\",\n    value: function shouldAttach(route) {\n      return false;\n    }\n    /**\n     * @param {?} route\n     * @return {?}\n     */\n\n  }, {\n    key: \"retrieve\",\n    value: function retrieve(route) {\n      return null;\n    }\n    /**\n     * @param {?} future\n     * @param {?} curr\n     * @return {?}\n     */\n\n  }, {\n    key: \"shouldReuseRoute\",\n    value: function shouldReuseRoute(future, curr) {\n      return future.routeConfig === curr.routeConfig;\n    }\n  }]);\n\n  return DefaultRouteReuseStrategy;\n}();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * \\@docsNotRequired\n * \\@experimental\n */\n\n\nvar ROUTES = /*#__PURE__*/new InjectionToken('ROUTES');\n\nvar RouterConfigLoader = /*#__PURE__*/function () {\n  /**\n   * @param {?} loader\n   * @param {?} compiler\n   * @param {?=} onLoadStartListener\n   * @param {?=} onLoadEndListener\n   */\n  function RouterConfigLoader(loader, compiler, onLoadStartListener, onLoadEndListener) {\n    _classCallCheck(this, RouterConfigLoader);\n\n    this.loader = loader;\n    this.compiler = compiler;\n    this.onLoadStartListener = onLoadStartListener;\n    this.onLoadEndListener = onLoadEndListener;\n  }\n  /**\n   * @param {?} parentInjector\n   * @param {?} route\n   * @return {?}\n   */\n\n\n  _createClass(RouterConfigLoader, [{\n    key: \"load\",\n    value: function load(parentInjector, route) {\n      var _this34 = this;\n\n      if (this.onLoadStartListener) {\n        this.onLoadStartListener(route);\n      }\n\n      var\n      /** @type {?} */\n      moduleFactory$ = this.loadModuleFactory(\n      /** @type {?} */\n      route.loadChildren);\n      return map.call(moduleFactory$, function (factory) {\n        if (_this34.onLoadEndListener) {\n          _this34.onLoadEndListener(route);\n        }\n\n        var\n        /** @type {?} */\n        module = factory.create(parentInjector);\n        return new LoadedRouterConfig(flatten(module.injector.get(ROUTES)).map(copyConfig), module);\n      });\n    }\n    /**\n     * @param {?} loadChildren\n     * @return {?}\n     */\n\n  }, {\n    key: \"loadModuleFactory\",\n    value: function loadModuleFactory(loadChildren) {\n      var _this35 = this;\n\n      if (typeof loadChildren === 'string') {\n        return fromPromise(this.loader.load(loadChildren));\n      } else {\n        return mergeMap.call(wrapIntoObservable(loadChildren()), function (t) {\n          if (t instanceof NgModuleFactory) {\n            return of(t);\n          } else {\n            return fromPromise(_this35.compiler.compileModuleAsync(t));\n          }\n        });\n      }\n    }\n  }]);\n\n  return RouterConfigLoader;\n}();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * \\@whatItDoes Provides a way to migrate AngularJS applications to Angular.\n *\n * \\@experimental\n * @abstract\n */\n\n\nvar UrlHandlingStrategy = /*#__PURE__*/_createClass(function UrlHandlingStrategy() {\n  _classCallCheck(this, UrlHandlingStrategy);\n});\n/**\n * \\@experimental\n */\n\n\nvar DefaultUrlHandlingStrategy = /*#__PURE__*/function () {\n  function DefaultUrlHandlingStrategy() {\n    _classCallCheck(this, DefaultUrlHandlingStrategy);\n  }\n\n  _createClass(DefaultUrlHandlingStrategy, [{\n    key: \"shouldProcessUrl\",\n    value:\n    /**\n     * @param {?} url\n     * @return {?}\n     */\n    function shouldProcessUrl(url) {\n      return true;\n    }\n    /**\n     * @param {?} url\n     * @return {?}\n     */\n\n  }, {\n    key: \"extract\",\n    value: function extract(url) {\n      return url;\n    }\n    /**\n     * @param {?} newUrlPart\n     * @param {?} wholeUrl\n     * @return {?}\n     */\n\n  }, {\n    key: \"merge\",\n    value: function merge(newUrlPart, wholeUrl) {\n      return newUrlPart;\n    }\n  }]);\n\n  return DefaultUrlHandlingStrategy;\n}();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * \\@whatItDoes Represents the extra options used during navigation.\n *\n * \\@stable\n * @record\n */\n\n/**\n * @param {?} error\n * @return {?}\n */\n\n\nfunction defaultErrorHandler(error) {\n  throw error;\n}\n/**\n * \\@internal\n * @param {?} snapshot\n * @return {?}\n */\n\n\nfunction defaultRouterHook(snapshot) {\n  return (\n    /** @type {?} */\n    of(null)\n  );\n}\n/**\n * \\@whatItDoes Provides the navigation and url manipulation capabilities.\n *\n * See {\\@link Routes} for more details and examples.\n *\n * \\@ngModule RouterModule\n *\n * \\@stable\n */\n\n\nvar Router = /*#__PURE__*/(function () {\n  var Router = /*#__PURE__*/function () {\n    /**\n     * Creates the router service.\n     * @param {?} rootComponentType\n     * @param {?} urlSerializer\n     * @param {?} rootContexts\n     * @param {?} location\n     * @param {?} injector\n     * @param {?} loader\n     * @param {?} compiler\n     * @param {?} config\n     */\n    function Router(rootComponentType, urlSerializer, rootContexts, location, injector, loader, compiler, config) {\n      var _this36 = this;\n\n      _classCallCheck(this, Router);\n\n      this.rootComponentType = rootComponentType;\n      this.urlSerializer = urlSerializer;\n      this.rootContexts = rootContexts;\n      this.location = location;\n      this.config = config;\n      this.navigations = new BehaviorSubject(\n      /** @type {?} */\n      null);\n      this.navigationId = 0;\n      this.events = new Subject();\n      /**\n       * Error handler that is invoked when a navigation errors.\n       *\n       * See {\\@link ErrorHandler} for more information.\n       */\n\n      this.errorHandler = defaultErrorHandler;\n      /**\n       * Indicates if at least one navigation happened.\n       */\n\n      this.navigated = false;\n      /**\n       * Used by RouterModule. This allows us to\n       * pause the navigation either before preactivation or after it.\n       * \\@internal\n       */\n\n      this.hooks = {\n        beforePreactivation: defaultRouterHook,\n        afterPreactivation: defaultRouterHook\n      };\n      /**\n       * Extracts and merges URLs. Used for AngularJS to Angular migrations.\n       */\n\n      this.urlHandlingStrategy = new DefaultUrlHandlingStrategy();\n      this.routeReuseStrategy = new DefaultRouteReuseStrategy();\n      /**\n       * Define what the router should do if it receives a navigation request to the current URL.\n       * By default, the router will ignore this navigation. However, this prevents features such\n       * as a \"refresh\" button. Use this option to configure the behavior when navigating to the\n       * current URL. Default is 'ignore'.\n       */\n\n      this.onSameUrlNavigation = 'ignore';\n      /**\n       * Defines how the router merges params, data and resolved data from parent to child\n       * routes. Available options are:\n       *\n       * - `'emptyOnly'`, the default, only inherits parent params for path-less or component-less\n       *   routes.\n       * - `'always'`, enables unconditional inheritance of parent params.\n       */\n\n      this.paramsInheritanceStrategy = 'emptyOnly';\n\n      var\n      /** @type {?} */\n      onLoadStart = function onLoadStart(r) {\n        return _this36.triggerEvent(new RouteConfigLoadStart(r));\n      };\n\n      var\n      /** @type {?} */\n      onLoadEnd = function onLoadEnd(r) {\n        return _this36.triggerEvent(new RouteConfigLoadEnd(r));\n      };\n\n      this.ngModule = injector.get(NgModuleRef);\n      this.resetConfig(config);\n      this.currentUrlTree = createEmptyUrlTree();\n      this.rawUrlTree = this.currentUrlTree;\n      this.configLoader = new RouterConfigLoader(loader, compiler, onLoadStart, onLoadEnd);\n      this.routerState = createEmptyState(this.currentUrlTree, this.rootComponentType);\n      this.processNavigations();\n    }\n    /**\n     * \\@internal\n     * TODO: this should be removed once the constructor of the router made internal\n     * @param {?} rootComponentType\n     * @return {?}\n     */\n\n\n    _createClass(Router, [{\n      key: \"resetRootComponentType\",\n      value: function resetRootComponentType(rootComponentType) {\n        this.rootComponentType = rootComponentType; // TODO: vsavkin router 4.0 should make the root component set to null\n        // this will simplify the lifecycle of the router.\n\n        this.routerState.root.component = this.rootComponentType;\n      }\n      /**\n       * Sets up the location change listener and performs the initial navigation.\n       * @return {?}\n       */\n\n    }, {\n      key: \"initialNavigation\",\n      value: function initialNavigation() {\n        this.setUpLocationChangeListener();\n\n        if (this.navigationId === 0) {\n          this.navigateByUrl(this.location.path(true), {\n            replaceUrl: true\n          });\n        }\n      }\n      /**\n       * Sets up the location change listener.\n       * @return {?}\n       */\n\n    }, {\n      key: \"setUpLocationChangeListener\",\n      value: function setUpLocationChangeListener() {\n        var _this37 = this;\n\n        // Don't need to use Zone.wrap any more, because zone.js\n        // already patch onPopState, so location change callback will\n        // run into ngZone\n        if (!this.locationSubscription) {\n          this.locationSubscription =\n          /** @type {?} */\n          this.location.subscribe(function (change) {\n            var\n            /** @type {?} */\n            rawUrlTree = _this37.urlSerializer.parse(change['url']);\n\n            var\n            /** @type {?} */\n            source = change['type'] === 'popstate' ? 'popstate' : 'hashchange';\n            setTimeout(function () {\n              _this37.scheduleNavigation(rawUrlTree, source, {\n                replaceUrl: true\n              });\n            }, 0);\n          });\n        }\n      }\n      /**\n       * The current url\n       * @return {?}\n       */\n\n    }, {\n      key: \"url\",\n      get: function get() {\n        return this.serializeUrl(this.currentUrlTree);\n      }\n      /**\n       * \\@internal\n       * @param {?} e\n       * @return {?}\n       */\n\n    }, {\n      key: \"triggerEvent\",\n      value: function triggerEvent(e) {\n        /** @type {?} */\n        this.events.next(e);\n      }\n      /**\n       * Resets the configuration used for navigation and generating links.\n       *\n       * ### Usage\n       *\n       * ```\n       * router.resetConfig([\n       *  { path: 'team/:id', component: TeamCmp, children: [\n       *    { path: 'simple', component: SimpleCmp },\n       *    { path: 'user/:name', component: UserCmp }\n       *  ]}\n       * ]);\n       * ```\n       * @param {?} config\n       * @return {?}\n       */\n\n    }, {\n      key: \"resetConfig\",\n      value: function resetConfig(config) {\n        validateConfig(config);\n        this.config = config.map(copyConfig);\n        this.navigated = false;\n      }\n      /**\n       * \\@docsNotRequired\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this.dispose();\n      }\n      /**\n       * Disposes of the router\n       * @return {?}\n       */\n\n    }, {\n      key: \"dispose\",\n      value: function dispose() {\n        if (this.locationSubscription) {\n          this.locationSubscription.unsubscribe();\n          this.locationSubscription =\n          /** @type {?} */\n          null;\n        }\n      }\n      /**\n       * Applies an array of commands to the current url tree and creates a new url tree.\n       *\n       * When given an activate route, applies the given commands starting from the route.\n       * When not given a route, applies the given command starting from the root.\n       *\n       * ### Usage\n       *\n       * ```\n       * // create /team/33/user/11\n       * router.createUrlTree(['/team', 33, 'user', 11]);\n       *\n       * // create /team/33;expand=true/user/11\n       * router.createUrlTree(['/team', 33, {expand: true}, 'user', 11]);\n       *\n       * // you can collapse static segments like this (this works only with the first passed-in value):\n       * router.createUrlTree(['/team/33/user', userId]);\n       *\n       * // If the first segment can contain slashes, and you do not want the router to split it, you\n       * // can do the following:\n       *\n       * router.createUrlTree([{segmentPath: '/one/two'}]);\n       *\n       * // create /team/33/(user/11//right:chat)\n       * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: 'chat'}}]);\n       *\n       * // remove the right secondary node\n       * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: null}}]);\n       *\n       * // assuming the current url is `/team/33/user/11` and the route points to `user/11`\n       *\n       * // navigate to /team/33/user/11/details\n       * router.createUrlTree(['details'], {relativeTo: route});\n       *\n       * // navigate to /team/33/user/22\n       * router.createUrlTree(['../22'], {relativeTo: route});\n       *\n       * // navigate to /team/44/user/22\n       * router.createUrlTree(['../../team/44/user/22'], {relativeTo: route});\n       * ```\n       * @param {?} commands\n       * @param {?=} navigationExtras\n       * @return {?}\n       */\n\n    }, {\n      key: \"createUrlTree\",\n      value: function createUrlTree(commands) {\n        var navigationExtras = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var relativeTo = navigationExtras.relativeTo,\n            queryParams = navigationExtras.queryParams,\n            fragment = navigationExtras.fragment,\n            preserveQueryParams = navigationExtras.preserveQueryParams,\n            queryParamsHandling = navigationExtras.queryParamsHandling,\n            preserveFragment = navigationExtras.preserveFragment;\n\n        if (isDevMode() && preserveQueryParams &&\n        /** @type {?} */\n        console &&\n        /** @type {?} */\n        console.warn) {\n          console.warn('preserveQueryParams is deprecated, use queryParamsHandling instead.');\n        }\n\n        var\n        /** @type {?} */\n        a = relativeTo || this.routerState.root;\n        var\n        /** @type {?} */\n        f = preserveFragment ? this.currentUrlTree.fragment : fragment;\n        var\n        /** @type {?} */\n        q = null;\n\n        if (queryParamsHandling) {\n          switch (queryParamsHandling) {\n            case 'merge':\n              q = Object.assign({}, this.currentUrlTree.queryParams, queryParams);\n              break;\n\n            case 'preserve':\n              q = this.currentUrlTree.queryParams;\n              break;\n\n            default:\n              q = queryParams || null;\n          }\n        } else {\n          q = preserveQueryParams ? this.currentUrlTree.queryParams : queryParams || null;\n        }\n\n        if (q !== null) {\n          q = this.removeEmptyProps(q);\n        }\n\n        return _createUrlTree(a, this.currentUrlTree, commands,\n        /** @type {?} */\n        q,\n        /** @type {?} */\n        f);\n      }\n      /**\n       * Navigate based on the provided url. This navigation is always absolute.\n       *\n       * Returns a promise that:\n       * - resolves to 'true' when navigation succeeds,\n       * - resolves to 'false' when navigation fails,\n       * - is rejected when an error happens.\n       *\n       * ### Usage\n       *\n       * ```\n       * router.navigateByUrl(\"/team/33/user/11\");\n       *\n       * // Navigate without updating the URL\n       * router.navigateByUrl(\"/team/33/user/11\", { skipLocationChange: true });\n       * ```\n       *\n       * In opposite to `navigate`, `navigateByUrl` takes a whole URL\n       * and does not apply any delta to the current one.\n       * @param {?} url\n       * @param {?=} extras\n       * @return {?}\n       */\n\n    }, {\n      key: \"navigateByUrl\",\n      value: function navigateByUrl(url) {\n        var extras = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n          skipLocationChange: false\n        };\n        var\n        /** @type {?} */\n        urlTree = url instanceof UrlTree ? url : this.parseUrl(url);\n        var\n        /** @type {?} */\n        mergedTree = this.urlHandlingStrategy.merge(urlTree, this.rawUrlTree);\n        return this.scheduleNavigation(mergedTree, 'imperative', extras);\n      }\n      /**\n       * Navigate based on the provided array of commands and a starting point.\n       * If no starting route is provided, the navigation is absolute.\n       *\n       * Returns a promise that:\n       * - resolves to 'true' when navigation succeeds,\n       * - resolves to 'false' when navigation fails,\n       * - is rejected when an error happens.\n       *\n       * ### Usage\n       *\n       * ```\n       * router.navigate(['team', 33, 'user', 11], {relativeTo: route});\n       *\n       * // Navigate without updating the URL\n       * router.navigate(['team', 33, 'user', 11], {relativeTo: route, skipLocationChange: true});\n       * ```\n       *\n       * In opposite to `navigateByUrl`, `navigate` always takes a delta that is applied to the current\n       * URL.\n       * @param {?} commands\n       * @param {?=} extras\n       * @return {?}\n       */\n\n    }, {\n      key: \"navigate\",\n      value: function navigate(commands) {\n        var extras = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n          skipLocationChange: false\n        };\n        validateCommands(commands);\n        return this.navigateByUrl(this.createUrlTree(commands, extras), extras);\n      }\n      /**\n       * Serializes a {\\@link UrlTree} into a string\n       * @param {?} url\n       * @return {?}\n       */\n\n    }, {\n      key: \"serializeUrl\",\n      value: function serializeUrl(url) {\n        return this.urlSerializer.serialize(url);\n      }\n      /**\n       * Parses a string into a {\\@link UrlTree}\n       * @param {?} url\n       * @return {?}\n       */\n\n    }, {\n      key: \"parseUrl\",\n      value: function parseUrl(url) {\n        return this.urlSerializer.parse(url);\n      }\n      /**\n       * Returns whether the url is activated\n       * @param {?} url\n       * @param {?} exact\n       * @return {?}\n       */\n\n    }, {\n      key: \"isActive\",\n      value: function isActive(url, exact) {\n        if (url instanceof UrlTree) {\n          return containsTree(this.currentUrlTree, url, exact);\n        }\n\n        var\n        /** @type {?} */\n        urlTree = this.urlSerializer.parse(url);\n        return containsTree(this.currentUrlTree, urlTree, exact);\n      }\n      /**\n       * @param {?} params\n       * @return {?}\n       */\n\n    }, {\n      key: \"removeEmptyProps\",\n      value: function removeEmptyProps(params) {\n        return Object.keys(params).reduce(function (result, key) {\n          var\n          /** @type {?} */\n          value = params[key];\n\n          if (value !== null && value !== undefined) {\n            result[key] = value;\n          }\n\n          return result;\n        }, {});\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"processNavigations\",\n      value: function processNavigations() {\n        var _this38 = this;\n\n        concatMap.call(this.navigations, function (nav) {\n          if (nav) {\n            _this38.executeScheduledNavigation(nav); // a failed navigation should not stop the router from processing\n            // further navigations => the catch\n\n\n            return nav.promise.catch(function () {});\n          } else {\n            return (\n              /** @type {?} */\n              of(null)\n            );\n          }\n        }).subscribe(function () {});\n      }\n      /**\n       * @param {?} rawUrl\n       * @param {?} source\n       * @param {?} extras\n       * @return {?}\n       */\n\n    }, {\n      key: \"scheduleNavigation\",\n      value: function scheduleNavigation(rawUrl, source, extras) {\n        var\n        /** @type {?} */\n        lastNavigation = this.navigations.value; // If the user triggers a navigation imperatively (e.g., by using navigateByUrl),\n        // and that navigation results in 'replaceState' that leads to the same URL,\n        // we should skip those.\n\n        if (lastNavigation && source !== 'imperative' && lastNavigation.source === 'imperative' && lastNavigation.rawUrl.toString() === rawUrl.toString()) {\n          return Promise.resolve(true); // return value is not used\n        } // Because of a bug in IE and Edge, the location class fires two events (popstate and\n        // hashchange) every single time. The second one should be ignored. Otherwise, the URL will\n        // flicker. Handles the case when a popstate was emitted first.\n\n\n        if (lastNavigation && source == 'hashchange' && lastNavigation.source === 'popstate' && lastNavigation.rawUrl.toString() === rawUrl.toString()) {\n          return Promise.resolve(true); // return value is not used\n        } // Because of a bug in IE and Edge, the location class fires two events (popstate and\n        // hashchange) every single time. The second one should be ignored. Otherwise, the URL will\n        // flicker. Handles the case when a hashchange was emitted first.\n\n\n        if (lastNavigation && source == 'popstate' && lastNavigation.source === 'hashchange' && lastNavigation.rawUrl.toString() === rawUrl.toString()) {\n          return Promise.resolve(true); // return value is not used\n        }\n\n        var\n        /** @type {?} */\n        resolve = null;\n        var\n        /** @type {?} */\n        reject = null;\n        var\n        /** @type {?} */\n        promise = new Promise(function (res, rej) {\n          resolve = res;\n          reject = rej;\n        });\n        var\n        /** @type {?} */\n        id = ++this.navigationId;\n        this.navigations.next({\n          id: id,\n          source: source,\n          rawUrl: rawUrl,\n          extras: extras,\n          resolve: resolve,\n          reject: reject,\n          promise: promise\n        }); // Make sure that the error is propagated even though `processNavigations` catch\n        // handler does not rethrow\n\n        return promise.catch(function (e) {\n          return Promise.reject(e);\n        });\n      }\n      /**\n       * @param {?} __0\n       * @return {?}\n       */\n\n    }, {\n      key: \"executeScheduledNavigation\",\n      value: function executeScheduledNavigation(_ref4) {\n        var _this39 = this;\n\n        var id = _ref4.id,\n            rawUrl = _ref4.rawUrl,\n            extras = _ref4.extras,\n            resolve = _ref4.resolve,\n            reject = _ref4.reject;\n        var\n        /** @type {?} */\n        url = this.urlHandlingStrategy.extract(rawUrl);\n        var\n        /** @type {?} */\n        urlTransition = !this.navigated || url.toString() !== this.currentUrlTree.toString();\n\n        if ((this.onSameUrlNavigation === 'reload' ? true : urlTransition) && this.urlHandlingStrategy.shouldProcessUrl(rawUrl)) {\n          /** @type {?} */\n          this.events.next(new NavigationStart(id, this.serializeUrl(url)));\n          Promise.resolve().then(function (_) {\n            return _this39.runNavigate(url, rawUrl, !!extras.skipLocationChange, !!extras.replaceUrl, id, null);\n          }).then(resolve, reject); // we cannot process the current URL, but we could process the previous one =>\n          // we need to do some cleanup\n        } else if (urlTransition && this.rawUrlTree && this.urlHandlingStrategy.shouldProcessUrl(this.rawUrlTree)) {\n          /** @type {?} */\n          this.events.next(new NavigationStart(id, this.serializeUrl(url)));\n          Promise.resolve().then(function (_) {\n            return _this39.runNavigate(url, rawUrl, false, false, id, createEmptyState(url, _this39.rootComponentType).snapshot);\n          }).then(resolve, reject);\n        } else {\n          this.rawUrlTree = rawUrl;\n          resolve(null);\n        }\n      }\n      /**\n       * @param {?} url\n       * @param {?} rawUrl\n       * @param {?} skipLocationChange\n       * @param {?} replaceUrl\n       * @param {?} id\n       * @param {?} precreatedState\n       * @return {?}\n       */\n\n    }, {\n      key: \"runNavigate\",\n      value: function runNavigate(url, rawUrl, skipLocationChange, replaceUrl, id, precreatedState) {\n        var _this40 = this;\n\n        if (id !== this.navigationId) {\n          /** @type {?} */\n          this.events.next(new NavigationCancel(id, this.serializeUrl(url), \"Navigation ID \".concat(id, \" is not equal to the current navigation id \").concat(this.navigationId)));\n          return Promise.resolve(false);\n        }\n\n        return new Promise(function (resolvePromise, rejectPromise) {\n          // create an observable of the url and route state snapshot\n          // this operation do not result in any side effects\n          var\n          /** @type {?} */\n          urlAndSnapshot$;\n\n          if (!precreatedState) {\n            var\n            /** @type {?} */\n            moduleInjector = _this40.ngModule.injector;\n            var\n            /** @type {?} */\n            redirectsApplied$ = applyRedirects(moduleInjector, _this40.configLoader, _this40.urlSerializer, url, _this40.config);\n            urlAndSnapshot$ = mergeMap.call(redirectsApplied$, function (appliedUrl) {\n              return map.call(recognize(_this40.rootComponentType, _this40.config, appliedUrl, _this40.serializeUrl(appliedUrl), _this40.paramsInheritanceStrategy), function (snapshot) {\n                /** @type {?} */\n                _this40.events.next(new RoutesRecognized(id, _this40.serializeUrl(url), _this40.serializeUrl(appliedUrl), snapshot));\n\n                return {\n                  appliedUrl: appliedUrl,\n                  snapshot: snapshot\n                };\n              });\n            });\n          } else {\n            urlAndSnapshot$ = of({\n              appliedUrl: url,\n              snapshot: precreatedState\n            });\n          }\n\n          var\n          /** @type {?} */\n          beforePreactivationDone$ = mergeMap.call(urlAndSnapshot$, function (p) {\n            return map.call(_this40.hooks.beforePreactivation(p.snapshot), function () {\n              return p;\n            });\n          }); // run preactivation: guards and data resolvers\n\n          var\n          /** @type {?} */\n          preActivation;\n          var\n          /** @type {?} */\n          preactivationSetup$ = map.call(beforePreactivationDone$, function (_ref5) {\n            var appliedUrl = _ref5.appliedUrl,\n                snapshot = _ref5.snapshot;\n            var\n            /** @type {?} */\n            moduleInjector = _this40.ngModule.injector;\n            preActivation = new PreActivation(snapshot, _this40.routerState.snapshot, moduleInjector, function (evt) {\n              return _this40.triggerEvent(evt);\n            });\n            preActivation.initialize(_this40.rootContexts);\n            return {\n              appliedUrl: appliedUrl,\n              snapshot: snapshot\n            };\n          });\n          var\n          /** @type {?} */\n          preactivationCheckGuards$ = mergeMap.call(preactivationSetup$, function (_ref6) {\n            var appliedUrl = _ref6.appliedUrl,\n                snapshot = _ref6.snapshot;\n            if (_this40.navigationId !== id) return of(false);\n\n            _this40.triggerEvent(new GuardsCheckStart(id, _this40.serializeUrl(url), appliedUrl, snapshot));\n\n            return map.call(preActivation.checkGuards(), function (shouldActivate) {\n              _this40.triggerEvent(new GuardsCheckEnd(id, _this40.serializeUrl(url), appliedUrl, snapshot, shouldActivate));\n\n              return {\n                appliedUrl: appliedUrl,\n                snapshot: snapshot,\n                shouldActivate: shouldActivate\n              };\n            });\n          });\n          var\n          /** @type {?} */\n          preactivationResolveData$ = mergeMap.call(preactivationCheckGuards$, function (p) {\n            if (_this40.navigationId !== id) return of(false);\n\n            if (p.shouldActivate && preActivation.isActivating()) {\n              _this40.triggerEvent(new ResolveStart(id, _this40.serializeUrl(url), p.appliedUrl, p.snapshot));\n\n              return map.call(preActivation.resolveData(_this40.paramsInheritanceStrategy), function () {\n                _this40.triggerEvent(new ResolveEnd(id, _this40.serializeUrl(url), p.appliedUrl, p.snapshot));\n\n                return p;\n              });\n            } else {\n              return of(p);\n            }\n          });\n          var\n          /** @type {?} */\n          preactivationDone$ = mergeMap.call(preactivationResolveData$, function (p) {\n            return map.call(_this40.hooks.afterPreactivation(p.snapshot), function () {\n              return p;\n            });\n          }); // create router state\n          // this operation has side effects => route state is being affected\n\n          var\n          /** @type {?} */\n          routerState$ = map.call(preactivationDone$, function (_ref7) {\n            var appliedUrl = _ref7.appliedUrl,\n                snapshot = _ref7.snapshot,\n                shouldActivate = _ref7.shouldActivate;\n\n            if (shouldActivate) {\n              var\n              /** @type {?} */\n              state = createRouterState(_this40.routeReuseStrategy, snapshot, _this40.routerState);\n              return {\n                appliedUrl: appliedUrl,\n                state: state,\n                shouldActivate: shouldActivate\n              };\n            } else {\n              return {\n                appliedUrl: appliedUrl,\n                state: null,\n                shouldActivate: shouldActivate\n              };\n            }\n          });\n\n          _this40.activateRoutes(routerState$, _this40.routerState, _this40.currentUrlTree, id, url, rawUrl, skipLocationChange, replaceUrl, resolvePromise, rejectPromise);\n        });\n      }\n      /**\n       * Performs the logic of activating routes. This is a synchronous process by default. While this\n       * is a private method, it could be overridden to make activation asynchronous.\n       * @param {?} state\n       * @param {?} storedState\n       * @param {?} storedUrl\n       * @param {?} id\n       * @param {?} url\n       * @param {?} rawUrl\n       * @param {?} skipLocationChange\n       * @param {?} replaceUrl\n       * @param {?} resolvePromise\n       * @param {?} rejectPromise\n       * @return {?}\n       */\n\n    }, {\n      key: \"activateRoutes\",\n      value: function activateRoutes(state, storedState, storedUrl, id, url, rawUrl, skipLocationChange, replaceUrl, resolvePromise, rejectPromise) {\n        var _this41 = this;\n\n        // applied the new router state\n        // this operation has side effects\n        var\n        /** @type {?} */\n        navigationIsSuccessful;\n        state.forEach(function (_ref8) {\n          var appliedUrl = _ref8.appliedUrl,\n              state = _ref8.state,\n              shouldActivate = _ref8.shouldActivate;\n\n          if (!shouldActivate || id !== _this41.navigationId) {\n            navigationIsSuccessful = false;\n            return;\n          }\n\n          _this41.currentUrlTree = appliedUrl;\n          _this41.rawUrlTree = _this41.urlHandlingStrategy.merge(_this41.currentUrlTree, rawUrl);\n\n          /** @type {?} */\n          _this41.routerState = state;\n\n          if (!skipLocationChange) {\n            var\n            /** @type {?} */\n            path = _this41.urlSerializer.serialize(_this41.rawUrlTree);\n\n            if (_this41.location.isCurrentPathEqualTo(path) || replaceUrl) {\n              _this41.location.replaceState(path);\n            } else {\n              _this41.location.go(path);\n            }\n          }\n\n          new ActivateRoutes(_this41.routeReuseStrategy, state, storedState, function (evt) {\n            return _this41.triggerEvent(evt);\n          }).activate(_this41.rootContexts);\n          navigationIsSuccessful = true;\n        }).then(function () {\n          if (navigationIsSuccessful) {\n            _this41.navigated = true;\n\n            /** @type {?} */\n            _this41.events.next(new NavigationEnd(id, _this41.serializeUrl(url), _this41.serializeUrl(_this41.currentUrlTree)));\n\n            resolvePromise(true);\n          } else {\n            _this41.resetUrlToCurrentUrlTree();\n\n            /** @type {?} */\n            _this41.events.next(new NavigationCancel(id, _this41.serializeUrl(url), ''));\n\n            resolvePromise(false);\n          }\n        }, function (e) {\n          if (isNavigationCancelingError(e)) {\n            _this41.navigated = true;\n\n            _this41.resetStateAndUrl(storedState, storedUrl, rawUrl);\n\n            /** @type {?} */\n            _this41.events.next(new NavigationCancel(id, _this41.serializeUrl(url), e.message));\n\n            resolvePromise(false);\n          } else {\n            _this41.resetStateAndUrl(storedState, storedUrl, rawUrl);\n\n            /** @type {?} */\n            _this41.events.next(new NavigationError(id, _this41.serializeUrl(url), e));\n\n            try {\n              resolvePromise(_this41.errorHandler(e));\n            } catch (\n            /** @type {?} */\n            ee) {\n              rejectPromise(ee);\n            }\n          }\n        });\n      }\n      /**\n       * @param {?} storedState\n       * @param {?} storedUrl\n       * @param {?} rawUrl\n       * @return {?}\n       */\n\n    }, {\n      key: \"resetStateAndUrl\",\n      value: function resetStateAndUrl(storedState, storedUrl, rawUrl) {\n        /** @type {?} */\n        this.routerState = storedState;\n        this.currentUrlTree = storedUrl;\n        this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, rawUrl);\n        this.resetUrlToCurrentUrlTree();\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"resetUrlToCurrentUrlTree\",\n      value: function resetUrlToCurrentUrlTree() {\n        this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree));\n      }\n    }]);\n\n    return Router;\n  }();\n\n  Router.ɵfac = function Router_Factory(t) {\n    ɵngcc0.ɵɵinvalidFactory();\n  };\n\n  Router.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: Router\n  });\n  return Router;\n})();\n\nvar ActivateRoutes = /*#__PURE__*/function () {\n  /**\n   * @param {?} routeReuseStrategy\n   * @param {?} futureState\n   * @param {?} currState\n   * @param {?} forwardEvent\n   */\n  function ActivateRoutes(routeReuseStrategy, futureState, currState, forwardEvent) {\n    _classCallCheck(this, ActivateRoutes);\n\n    this.routeReuseStrategy = routeReuseStrategy;\n    this.futureState = futureState;\n    this.currState = currState;\n    this.forwardEvent = forwardEvent;\n  }\n  /**\n   * @param {?} parentContexts\n   * @return {?}\n   */\n\n\n  _createClass(ActivateRoutes, [{\n    key: \"activate\",\n    value: function activate(parentContexts) {\n      var\n      /** @type {?} */\n      futureRoot = this.futureState._root;\n      var\n      /** @type {?} */\n      currRoot = this.currState ? this.currState._root : null;\n      this.deactivateChildRoutes(futureRoot, currRoot, parentContexts);\n      advanceActivatedRoute(this.futureState.root);\n      this.activateChildRoutes(futureRoot, currRoot, parentContexts);\n    }\n    /**\n     * @param {?} futureNode\n     * @param {?} currNode\n     * @param {?} contexts\n     * @return {?}\n     */\n\n  }, {\n    key: \"deactivateChildRoutes\",\n    value: function deactivateChildRoutes(futureNode, currNode, contexts) {\n      var _this42 = this;\n\n      var\n      /** @type {?} */\n      children = nodeChildrenAsMap(currNode); // Recurse on the routes active in the future state to de-activate deeper children\n\n      futureNode.children.forEach(function (futureChild) {\n        var\n        /** @type {?} */\n        childOutletName = futureChild.value.outlet;\n\n        _this42.deactivateRoutes(futureChild, children[childOutletName], contexts);\n\n        delete children[childOutletName];\n      }); // De-activate the routes that will not be re-used\n\n      forEach(children, function (v, childName) {\n        _this42.deactivateRouteAndItsChildren(v, contexts);\n      });\n    }\n    /**\n     * @param {?} futureNode\n     * @param {?} currNode\n     * @param {?} parentContext\n     * @return {?}\n     */\n\n  }, {\n    key: \"deactivateRoutes\",\n    value: function deactivateRoutes(futureNode, currNode, parentContext) {\n      var\n      /** @type {?} */\n      future = futureNode.value;\n      var\n      /** @type {?} */\n      curr = currNode ? currNode.value : null;\n\n      if (future === curr) {\n        // Reusing the node, check to see if the children need to be de-activated\n        if (future.component) {\n          // If we have a normal route, we need to go through an outlet.\n          var\n          /** @type {?} */\n          context = parentContext.getContext(future.outlet);\n\n          if (context) {\n            this.deactivateChildRoutes(futureNode, currNode, context.children);\n          }\n        } else {\n          // if we have a componentless route, we recurse but keep the same outlet map.\n          this.deactivateChildRoutes(futureNode, currNode, parentContext);\n        }\n      } else {\n        if (curr) {\n          // Deactivate the current route which will not be re-used\n          this.deactivateRouteAndItsChildren(currNode, parentContext);\n        }\n      }\n    }\n    /**\n     * @param {?} route\n     * @param {?} parentContexts\n     * @return {?}\n     */\n\n  }, {\n    key: \"deactivateRouteAndItsChildren\",\n    value: function deactivateRouteAndItsChildren(route, parentContexts) {\n      if (this.routeReuseStrategy.shouldDetach(route.value.snapshot)) {\n        this.detachAndStoreRouteSubtree(route, parentContexts);\n      } else {\n        this.deactivateRouteAndOutlet(route, parentContexts);\n      }\n    }\n    /**\n     * @param {?} route\n     * @param {?} parentContexts\n     * @return {?}\n     */\n\n  }, {\n    key: \"detachAndStoreRouteSubtree\",\n    value: function detachAndStoreRouteSubtree(route, parentContexts) {\n      var\n      /** @type {?} */\n      context = parentContexts.getContext(route.value.outlet);\n\n      if (context && context.outlet) {\n        var\n        /** @type {?} */\n        componentRef = context.outlet.detach();\n        var\n        /** @type {?} */\n        contexts = context.children.onOutletDeactivated();\n        this.routeReuseStrategy.store(route.value.snapshot, {\n          componentRef: componentRef,\n          route: route,\n          contexts: contexts\n        });\n      }\n    }\n    /**\n     * @param {?} route\n     * @param {?} parentContexts\n     * @return {?}\n     */\n\n  }, {\n    key: \"deactivateRouteAndOutlet\",\n    value: function deactivateRouteAndOutlet(route, parentContexts) {\n      var _this43 = this;\n\n      var\n      /** @type {?} */\n      context = parentContexts.getContext(route.value.outlet);\n\n      if (context) {\n        var\n        /** @type {?} */\n        children = nodeChildrenAsMap(route);\n        var\n        /** @type {?} */\n        contexts = route.value.component ? context.children : parentContexts;\n        forEach(children, function (v, k) {\n          return _this43.deactivateRouteAndItsChildren(v, contexts);\n        });\n\n        if (context.outlet) {\n          // Destroy the component\n          context.outlet.deactivate(); // Destroy the contexts for all the outlets that were in the component\n\n          context.children.onOutletDeactivated();\n        }\n      }\n    }\n    /**\n     * @param {?} futureNode\n     * @param {?} currNode\n     * @param {?} contexts\n     * @return {?}\n     */\n\n  }, {\n    key: \"activateChildRoutes\",\n    value: function activateChildRoutes(futureNode, currNode, contexts) {\n      var _this44 = this;\n\n      var\n      /** @type {?} */\n      children = nodeChildrenAsMap(currNode);\n      futureNode.children.forEach(function (c) {\n        _this44.activateRoutes(c, children[c.value.outlet], contexts);\n\n        _this44.forwardEvent(new ActivationEnd(c.value.snapshot));\n      });\n\n      if (futureNode.children.length) {\n        this.forwardEvent(new ChildActivationEnd(futureNode.value.snapshot));\n      }\n    }\n    /**\n     * @param {?} futureNode\n     * @param {?} currNode\n     * @param {?} parentContexts\n     * @return {?}\n     */\n\n  }, {\n    key: \"activateRoutes\",\n    value: function activateRoutes(futureNode, currNode, parentContexts) {\n      var\n      /** @type {?} */\n      future = futureNode.value;\n      var\n      /** @type {?} */\n      curr = currNode ? currNode.value : null;\n      advanceActivatedRoute(future); // reusing the node\n\n      if (future === curr) {\n        if (future.component) {\n          // If we have a normal route, we need to go through an outlet.\n          var\n          /** @type {?} */\n          context = parentContexts.getOrCreateContext(future.outlet);\n          this.activateChildRoutes(futureNode, currNode, context.children);\n        } else {\n          // if we have a componentless route, we recurse but keep the same outlet map.\n          this.activateChildRoutes(futureNode, currNode, parentContexts);\n        }\n      } else {\n        if (future.component) {\n          // if we have a normal route, we need to place the component into the outlet and recurse.\n          var\n          /** @type {?} */\n          _context = parentContexts.getOrCreateContext(future.outlet);\n\n          if (this.routeReuseStrategy.shouldAttach(future.snapshot)) {\n            var\n            /** @type {?} */\n            stored =\n            /** @type {?} */\n            this.routeReuseStrategy.retrieve(future.snapshot);\n            this.routeReuseStrategy.store(future.snapshot, null);\n\n            _context.children.onOutletReAttached(stored.contexts);\n\n            _context.attachRef = stored.componentRef;\n            _context.route = stored.route.value;\n\n            if (_context.outlet) {\n              // Attach right away when the outlet has already been instantiated\n              // Otherwise attach from `RouterOutlet.ngOnInit` when it is instantiated\n              _context.outlet.attach(stored.componentRef, stored.route.value);\n            }\n\n            advanceActivatedRouteNodeAndItsChildren(stored.route);\n          } else {\n            var\n            /** @type {?} */\n            config = parentLoadedConfig(future.snapshot);\n            var\n            /** @type {?} */\n            cmpFactoryResolver = config ? config.module.componentFactoryResolver : null;\n            _context.route = future;\n            _context.resolver = cmpFactoryResolver;\n\n            if (_context.outlet) {\n              // Activate the outlet when it has already been instantiated\n              // Otherwise it will get activated from its `ngOnInit` when instantiated\n              _context.outlet.activateWith(future, cmpFactoryResolver);\n            }\n\n            this.activateChildRoutes(futureNode, null, _context.children);\n          }\n        } else {\n          // if we have a componentless route, we recurse but keep the same outlet map.\n          this.activateChildRoutes(futureNode, null, parentContexts);\n        }\n      }\n    }\n  }]);\n\n  return ActivateRoutes;\n}();\n/**\n * @param {?} node\n * @return {?}\n */\n\n\nfunction advanceActivatedRouteNodeAndItsChildren(node) {\n  advanceActivatedRoute(node.value);\n  node.children.forEach(advanceActivatedRouteNodeAndItsChildren);\n}\n/**\n * @param {?} snapshot\n * @return {?}\n */\n\n\nfunction parentLoadedConfig(snapshot) {\n  for (var\n  /** @type {?} */\n  s = snapshot.parent; s; s = s.parent) {\n    var\n    /** @type {?} */\n    route = s.routeConfig;\n    if (route && route._loadedConfig) return route._loadedConfig;\n    if (route && route.component) return null;\n  }\n\n  return null;\n}\n/**\n * @param {?} commands\n * @return {?}\n */\n\n\nfunction validateCommands(commands) {\n  for (var\n  /** @type {?} */\n  i = 0; i < commands.length; i++) {\n    var\n    /** @type {?} */\n    cmd = commands[i];\n\n    if (cmd == null) {\n      throw new Error(\"The requested path contains \".concat(cmd, \" segment at index \").concat(i));\n    }\n  }\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * \\@whatItDoes Lets you link to specific parts of your app.\n *\n * \\@howToUse\n *\n * Consider the following route configuration:\n * `[{ path: 'user/:name', component: UserCmp }]`\n *\n * When linking to this `user/:name` route, you can write:\n * `<a routerLink='/user/bob'>link to user component</a>`\n *\n * \\@description\n *\n * The RouterLink directives let you link to specific parts of your app.\n *\n * When the link is static, you can use the directive as follows:\n * `<a routerLink=\"/user/bob\">link to user component</a>`\n *\n * If you use dynamic values to generate the link, you can pass an array of path\n * segments, followed by the params for each segment.\n *\n * For instance `['/team', teamId, 'user', userName, {details: true}]`\n * means that we want to generate a link to `/team/11/user/bob;details=true`.\n *\n * Multiple static segments can be merged into one\n * (e.g., `['/team/11/user', userName, {details: true}]`).\n *\n * The first segment name can be prepended with `/`, `./`, or `../`:\n * * If the first segment begins with `/`, the router will look up the route from the root of the\n *   app.\n * * If the first segment begins with `./`, or doesn't begin with a slash, the router will\n *   instead look in the children of the current activated route.\n * * And if the first segment begins with `../`, the router will go up one level.\n *\n * You can set query params and fragment as follows:\n *\n * ```\n * <a [routerLink]=\"['/user/bob']\" [queryParams]=\"{debug: true}\" fragment=\"education\">\n *   link to user component\n * </a>\n * ```\n * RouterLink will use these to generate this link: `/user/bob#education?debug=true`.\n *\n * (Deprecated in v4.0.0 use `queryParamsHandling` instead) You can also tell the\n * directive to preserve the current query params and fragment:\n *\n * ```\n * <a [routerLink]=\"['/user/bob']\" preserveQueryParams preserveFragment>\n *   link to user component\n * </a>\n * ```\n *\n * You can tell the directive to how to handle queryParams, available options are:\n *  - `'merge'`: merge the queryParams into the current queryParams\n *  - `'preserve'`: preserve the current queryParams\n *  - default/`''`: use the queryParams only\n *\n * Same options for {\\@link NavigationExtras#queryParamsHandling\n * NavigationExtras#queryParamsHandling}.\n *\n * ```\n * <a [routerLink]=\"['/user/bob']\" [queryParams]=\"{debug: true}\" queryParamsHandling=\"merge\">\n *   link to user component\n * </a>\n * ```\n *\n * The router link directive always treats the provided input as a delta to the current url.\n *\n * For instance, if the current url is `/user/(box//aux:team)`.\n *\n * Then the following link `<a [routerLink]=\"['/user/jim']\">Jim</a>` will generate the link\n * `/user/(jim//aux:team)`.\n *\n * See {\\@link Router#createUrlTree createUrlTree} for more information.\n *\n * \\@ngModule RouterModule\n *\n * \\@stable\n */\n\n\nvar RouterLink = /*#__PURE__*/(function () {\n  var RouterLink = /*#__PURE__*/function () {\n    /**\n     * @param {?} router\n     * @param {?} route\n     * @param {?} tabIndex\n     * @param {?} renderer\n     * @param {?} el\n     */\n    function RouterLink(router, route, tabIndex, renderer, el) {\n      _classCallCheck(this, RouterLink);\n\n      this.router = router;\n      this.route = route;\n      this.commands = [];\n\n      if (tabIndex == null) {\n        renderer.setAttribute(el.nativeElement, 'tabindex', '0');\n      }\n    }\n    /**\n     * @param {?} commands\n     * @return {?}\n     */\n\n\n    _createClass(RouterLink, [{\n      key: \"routerLink\",\n      set: function set(commands) {\n        if (commands != null) {\n          this.commands = Array.isArray(commands) ? commands : [commands];\n        } else {\n          this.commands = [];\n        }\n      }\n      /**\n       * @deprecated 4.0.0 use `queryParamsHandling` instead.\n       * @param {?} value\n       * @return {?}\n       */\n\n    }, {\n      key: \"preserveQueryParams\",\n      set: function set(value) {\n        if (isDevMode() &&\n        /** @type {?} */\n        console &&\n        /** @type {?} */\n        console.warn) {\n          console.warn('preserveQueryParams is deprecated!, use queryParamsHandling instead.');\n        }\n\n        this.preserve = value;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"onClick\",\n      value: function onClick() {\n        var\n        /** @type {?} */\n        extras = {\n          skipLocationChange: attrBoolValue(this.skipLocationChange),\n          replaceUrl: attrBoolValue(this.replaceUrl)\n        };\n        this.router.navigateByUrl(this.urlTree, extras);\n        return true;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"urlTree\",\n      get: function get() {\n        return this.router.createUrlTree(this.commands, {\n          relativeTo: this.route,\n          queryParams: this.queryParams,\n          fragment: this.fragment,\n          preserveQueryParams: attrBoolValue(this.preserve),\n          queryParamsHandling: this.queryParamsHandling,\n          preserveFragment: attrBoolValue(this.preserveFragment)\n        });\n      }\n    }]);\n\n    return RouterLink;\n  }();\n\n  RouterLink.ɵfac = function RouterLink_Factory(t) {\n    return new (t || RouterLink)(ɵngcc0.ɵɵdirectiveInject(Router), ɵngcc0.ɵɵdirectiveInject(ActivatedRoute), ɵngcc0.ɵɵinjectAttribute('tabindex'), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n  };\n\n  RouterLink.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: RouterLink,\n    selectors: [[\"\", \"routerLink\", \"\", 5, \"a\"]],\n    hostBindings: function RouterLink_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"click\", function RouterLink_click_HostBindingHandler() {\n          return ctx.onClick();\n        });\n      }\n    },\n    inputs: {\n      routerLink: \"routerLink\",\n      preserveQueryParams: \"preserveQueryParams\",\n      queryParams: \"queryParams\",\n      fragment: \"fragment\",\n      queryParamsHandling: \"queryParamsHandling\",\n      preserveFragment: \"preserveFragment\",\n      skipLocationChange: \"skipLocationChange\",\n      replaceUrl: \"replaceUrl\"\n    }\n  });\n  /** @nocollapse */\n\n  return RouterLink;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * \\@whatItDoes Lets you link to specific parts of your app.\n *\n * See {\\@link RouterLink} for more information.\n *\n * \\@ngModule RouterModule\n *\n * \\@stable\n */\n\n\nvar RouterLinkWithHref = /*#__PURE__*/(function () {\n  var RouterLinkWithHref = /*#__PURE__*/function () {\n    /**\n     * @param {?} router\n     * @param {?} route\n     * @param {?} locationStrategy\n     */\n    function RouterLinkWithHref(router, route, locationStrategy) {\n      var _this45 = this;\n\n      _classCallCheck(this, RouterLinkWithHref);\n\n      this.router = router;\n      this.route = route;\n      this.locationStrategy = locationStrategy;\n      this.commands = [];\n      this.subscription = router.events.subscribe(function (s) {\n        if (s instanceof NavigationEnd) {\n          _this45.updateTargetUrlAndHref();\n        }\n      });\n    }\n    /**\n     * @param {?} commands\n     * @return {?}\n     */\n\n\n    _createClass(RouterLinkWithHref, [{\n      key: \"routerLink\",\n      set: function set(commands) {\n        if (commands != null) {\n          this.commands = Array.isArray(commands) ? commands : [commands];\n        } else {\n          this.commands = [];\n        }\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n\n    }, {\n      key: \"preserveQueryParams\",\n      set: function set(value) {\n        if (isDevMode() &&\n        /** @type {?} */\n        console &&\n        /** @type {?} */\n        console.warn) {\n          console.warn('preserveQueryParams is deprecated, use queryParamsHandling instead.');\n        }\n\n        this.preserve = value;\n      }\n      /**\n       * @param {?} changes\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnChanges\",\n      value: function ngOnChanges(changes) {\n        this.updateTargetUrlAndHref();\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this.subscription.unsubscribe();\n      }\n      /**\n       * @param {?} button\n       * @param {?} ctrlKey\n       * @param {?} metaKey\n       * @param {?} shiftKey\n       * @return {?}\n       */\n\n    }, {\n      key: \"onClick\",\n      value: function onClick(button, ctrlKey, metaKey, shiftKey) {\n        if (button !== 0 || ctrlKey || metaKey || shiftKey) {\n          return true;\n        }\n\n        if (typeof this.target === 'string' && this.target != '_self') {\n          return true;\n        }\n\n        var\n        /** @type {?} */\n        extras = {\n          skipLocationChange: attrBoolValue(this.skipLocationChange),\n          replaceUrl: attrBoolValue(this.replaceUrl)\n        };\n        this.router.navigateByUrl(this.urlTree, extras);\n        return false;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"updateTargetUrlAndHref\",\n      value: function updateTargetUrlAndHref() {\n        this.href = this.locationStrategy.prepareExternalUrl(this.router.serializeUrl(this.urlTree));\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"urlTree\",\n      get: function get() {\n        return this.router.createUrlTree(this.commands, {\n          relativeTo: this.route,\n          queryParams: this.queryParams,\n          fragment: this.fragment,\n          preserveQueryParams: attrBoolValue(this.preserve),\n          queryParamsHandling: this.queryParamsHandling,\n          preserveFragment: attrBoolValue(this.preserveFragment)\n        });\n      }\n    }]);\n\n    return RouterLinkWithHref;\n  }();\n\n  RouterLinkWithHref.ɵfac = function RouterLinkWithHref_Factory(t) {\n    return new (t || RouterLinkWithHref)(ɵngcc0.ɵɵdirectiveInject(Router), ɵngcc0.ɵɵdirectiveInject(ActivatedRoute), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocationStrategy));\n  };\n\n  RouterLinkWithHref.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: RouterLinkWithHref,\n    selectors: [[\"a\", \"routerLink\", \"\"]],\n    hostVars: 2,\n    hostBindings: function RouterLinkWithHref_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"click\", function RouterLinkWithHref_click_HostBindingHandler($event) {\n          return ctx.onClick($event.button, $event.ctrlKey, $event.metaKey, $event.shiftKey);\n        });\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵhostProperty(\"href\", ctx.href, ɵngcc0.ɵɵsanitizeUrl);\n        ɵngcc0.ɵɵattribute(\"target\", ctx.target);\n      }\n    },\n    inputs: {\n      routerLink: \"routerLink\",\n      preserveQueryParams: \"preserveQueryParams\",\n      target: \"target\",\n      queryParams: \"queryParams\",\n      fragment: \"fragment\",\n      queryParamsHandling: \"queryParamsHandling\",\n      preserveFragment: \"preserveFragment\",\n      skipLocationChange: \"skipLocationChange\",\n      replaceUrl: \"replaceUrl\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n  /** @nocollapse */\n\n  return RouterLinkWithHref;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @param {?} s\n * @return {?}\n */\n\n\nfunction attrBoolValue(s) {\n  return s === '' || !!s;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * \\@whatItDoes Lets you add a CSS class to an element when the link's route becomes active.\n *\n * \\@howToUse\n *\n * ```\n * <a routerLink=\"/user/bob\" routerLinkActive=\"active-link\">Bob</a>\n * ```\n *\n * \\@description\n *\n * The RouterLinkActive directive lets you add a CSS class to an element when the link's route\n * becomes active.\n *\n * Consider the following example:\n *\n * ```\n * <a routerLink=\"/user/bob\" routerLinkActive=\"active-link\">Bob</a>\n * ```\n *\n * When the url is either '/user' or '/user/bob', the active-link class will\n * be added to the `a` tag. If the url changes, the class will be removed.\n *\n * You can set more than one class, as follows:\n *\n * ```\n * <a routerLink=\"/user/bob\" routerLinkActive=\"class1 class2\">Bob</a>\n * <a routerLink=\"/user/bob\" [routerLinkActive]=\"['class1', 'class2']\">Bob</a>\n * ```\n *\n * You can configure RouterLinkActive by passing `exact: true`. This will add the classes\n * only when the url matches the link exactly.\n *\n * ```\n * <a routerLink=\"/user/bob\" routerLinkActive=\"active-link\" [routerLinkActiveOptions]=\"{exact:\n * true}\">Bob</a>\n * ```\n *\n * You can assign the RouterLinkActive instance to a template variable and directly check\n * the `isActive` status.\n * ```\n * <a routerLink=\"/user/bob\" routerLinkActive #rla=\"routerLinkActive\">\n *   Bob {{ rla.isActive ? '(already open)' : ''}}\n * </a>\n * ```\n *\n * Finally, you can apply the RouterLinkActive directive to an ancestor of a RouterLink.\n *\n * ```\n * <div routerLinkActive=\"active-link\" [routerLinkActiveOptions]=\"{exact: true}\">\n *   <a routerLink=\"/user/jim\">Jim</a>\n *   <a routerLink=\"/user/bob\">Bob</a>\n * </div>\n * ```\n *\n * This will set the active-link class on the div tag if the url is either '/user/jim' or\n * '/user/bob'.\n *\n * \\@ngModule RouterModule\n *\n * \\@stable\n */\n\n\nvar RouterLinkActive = /*#__PURE__*/(function () {\n  var RouterLinkActive = /*#__PURE__*/function () {\n    /**\n     * @param {?} router\n     * @param {?} element\n     * @param {?} renderer\n     * @param {?} cdr\n     */\n    function RouterLinkActive(router, element, renderer, cdr) {\n      var _this46 = this;\n\n      _classCallCheck(this, RouterLinkActive);\n\n      this.router = router;\n      this.element = element;\n      this.renderer = renderer;\n      this.cdr = cdr;\n      this.classes = [];\n      this.isActive = false;\n      this.routerLinkActiveOptions = {\n        exact: false\n      };\n      this.subscription = router.events.subscribe(function (s) {\n        if (s instanceof NavigationEnd) {\n          _this46.update();\n        }\n      });\n    }\n    /**\n     * @return {?}\n     */\n\n\n    _createClass(RouterLinkActive, [{\n      key: \"ngAfterContentInit\",\n      value: function ngAfterContentInit() {\n        var _this47 = this;\n\n        this.links.changes.subscribe(function (_) {\n          return _this47.update();\n        });\n        this.linksWithHrefs.changes.subscribe(function (_) {\n          return _this47.update();\n        });\n        this.update();\n      }\n      /**\n       * @param {?} data\n       * @return {?}\n       */\n\n    }, {\n      key: \"routerLinkActive\",\n      set: function set(data) {\n        var\n        /** @type {?} */\n        classes = Array.isArray(data) ? data : data.split(' ');\n        this.classes = classes.filter(function (c) {\n          return !!c;\n        });\n      }\n      /**\n       * @param {?} changes\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnChanges\",\n      value: function ngOnChanges(changes) {\n        this.update();\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this.subscription.unsubscribe();\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"update\",\n      value: function update() {\n        var _this48 = this;\n\n        if (!this.links || !this.linksWithHrefs || !this.router.navigated) return;\n        Promise.resolve().then(function () {\n          var\n          /** @type {?} */\n          hasActiveLinks = _this48.hasActiveLinks();\n\n          if (_this48.isActive !== hasActiveLinks) {\n            /** @type {?} */\n            _this48.isActive = hasActiveLinks;\n\n            _this48.classes.forEach(function (c) {\n              if (hasActiveLinks) {\n                _this48.renderer.addClass(_this48.element.nativeElement, c);\n              } else {\n                _this48.renderer.removeClass(_this48.element.nativeElement, c);\n              }\n            });\n          }\n        });\n      }\n      /**\n       * @param {?} router\n       * @return {?}\n       */\n\n    }, {\n      key: \"isLinkActive\",\n      value: function isLinkActive(router) {\n        var _this49 = this;\n\n        return function (link) {\n          return router.isActive(link.urlTree, _this49.routerLinkActiveOptions.exact);\n        };\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"hasActiveLinks\",\n      value: function hasActiveLinks() {\n        return this.links.some(this.isLinkActive(this.router)) || this.linksWithHrefs.some(this.isLinkActive(this.router));\n      }\n    }]);\n\n    return RouterLinkActive;\n  }();\n\n  RouterLinkActive.ɵfac = function RouterLinkActive_Factory(t) {\n    return new (t || RouterLinkActive)(ɵngcc0.ɵɵdirectiveInject(Router), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef));\n  };\n\n  RouterLinkActive.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: RouterLinkActive,\n    selectors: [[\"\", \"routerLinkActive\", \"\"]],\n    contentQueries: function RouterLinkActive_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵcontentQuery(dirIndex, RouterLink, 5);\n        ɵngcc0.ɵɵcontentQuery(dirIndex, RouterLinkWithHref, 5);\n      }\n\n      if (rf & 2) {\n        var _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.links = _t);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.linksWithHrefs = _t);\n      }\n    },\n    inputs: {\n      routerLinkActiveOptions: \"routerLinkActiveOptions\",\n      routerLinkActive: \"routerLinkActive\"\n    },\n    exportAs: [\"routerLinkActive\"],\n    features: [ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n  /** @nocollapse */\n\n  return RouterLinkActive;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Store contextual information about a {\\@link RouterOutlet}\n *\n * \\@stable\n */\n\n\nvar OutletContext = /*#__PURE__*/_createClass(function OutletContext() {\n  _classCallCheck(this, OutletContext);\n\n  this.outlet = null;\n  this.route = null;\n  this.resolver = null;\n  this.children = new ChildrenOutletContexts();\n  this.attachRef = null;\n});\n/**\n * Store contextual information about the children (= nested) {\\@link RouterOutlet}\n *\n * \\@stable\n */\n\n\nvar ChildrenOutletContexts = /*#__PURE__*/function () {\n  function ChildrenOutletContexts() {\n    _classCallCheck(this, ChildrenOutletContexts);\n\n    this.contexts = new Map();\n  }\n  /**\n   * Called when a `RouterOutlet` directive is instantiated\n   * @param {?} childName\n   * @param {?} outlet\n   * @return {?}\n   */\n\n\n  _createClass(ChildrenOutletContexts, [{\n    key: \"onChildOutletCreated\",\n    value: function onChildOutletCreated(childName, outlet) {\n      var\n      /** @type {?} */\n      context = this.getOrCreateContext(childName);\n      context.outlet = outlet;\n      this.contexts.set(childName, context);\n    }\n    /**\n     * Called when a `RouterOutlet` directive is destroyed.\n     * We need to keep the context as the outlet could be destroyed inside a NgIf and might be\n     * re-created later.\n     * @param {?} childName\n     * @return {?}\n     */\n\n  }, {\n    key: \"onChildOutletDestroyed\",\n    value: function onChildOutletDestroyed(childName) {\n      var\n      /** @type {?} */\n      context = this.getContext(childName);\n\n      if (context) {\n        context.outlet = null;\n      }\n    }\n    /**\n     * Called when the corresponding route is deactivated during navigation.\n     * Because the component get destroyed, all children outlet are destroyed.\n     * @return {?}\n     */\n\n  }, {\n    key: \"onOutletDeactivated\",\n    value: function onOutletDeactivated() {\n      var\n      /** @type {?} */\n      contexts = this.contexts;\n      this.contexts = new Map();\n      return contexts;\n    }\n    /**\n     * @param {?} contexts\n     * @return {?}\n     */\n\n  }, {\n    key: \"onOutletReAttached\",\n    value: function onOutletReAttached(contexts) {\n      this.contexts = contexts;\n    }\n    /**\n     * @param {?} childName\n     * @return {?}\n     */\n\n  }, {\n    key: \"getOrCreateContext\",\n    value: function getOrCreateContext(childName) {\n      var\n      /** @type {?} */\n      context = this.getContext(childName);\n\n      if (!context) {\n        context = new OutletContext();\n        this.contexts.set(childName, context);\n      }\n\n      return context;\n    }\n    /**\n     * @param {?} childName\n     * @return {?}\n     */\n\n  }, {\n    key: \"getContext\",\n    value: function getContext(childName) {\n      return this.contexts.get(childName) || null;\n    }\n  }]);\n\n  return ChildrenOutletContexts;\n}();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * \\@whatItDoes Acts as a placeholder that Angular dynamically fills based on the current router\n * state.\n *\n * \\@howToUse\n *\n * ```\n * <router-outlet></router-outlet>\n * <router-outlet name='left'></router-outlet>\n * <router-outlet name='right'></router-outlet>\n * ```\n *\n * A router outlet will emit an activate event any time a new component is being instantiated,\n * and a deactivate event when it is being destroyed.\n *\n * ```\n * <router-outlet\n *   (activate)='onActivate($event)'\n *   (deactivate)='onDeactivate($event)'></router-outlet>\n * ```\n * \\@ngModule RouterModule\n *\n * \\@stable\n */\n\n\nvar RouterOutlet = /*#__PURE__*/(function () {\n  var RouterOutlet = /*#__PURE__*/function () {\n    /**\n     * @param {?} parentContexts\n     * @param {?} location\n     * @param {?} resolver\n     * @param {?} name\n     * @param {?} changeDetector\n     */\n    function RouterOutlet(parentContexts, location, resolver, name, changeDetector) {\n      _classCallCheck(this, RouterOutlet);\n\n      this.parentContexts = parentContexts;\n      this.location = location;\n      this.resolver = resolver;\n      this.changeDetector = changeDetector;\n      this.activated = null;\n      this._activatedRoute = null;\n      this.activateEvents = new EventEmitter();\n      this.deactivateEvents = new EventEmitter();\n      this.name = name || PRIMARY_OUTLET;\n      parentContexts.onChildOutletCreated(this.name, this);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    _createClass(RouterOutlet, [{\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this.parentContexts.onChildOutletDestroyed(this.name);\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnInit\",\n      value: function ngOnInit() {\n        if (!this.activated) {\n          // If the outlet was not instantiated at the time the route got activated we need to populate\n          // the outlet when it is initialized (ie inside a NgIf)\n          var\n          /** @type {?} */\n          context = this.parentContexts.getContext(this.name);\n\n          if (context && context.route) {\n            if (context.attachRef) {\n              // `attachRef` is populated when there is an existing component to mount\n              this.attach(context.attachRef, context.route);\n            } else {\n              // otherwise the component defined in the configuration is created\n              this.activateWith(context.route, context.resolver || null);\n            }\n          }\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"isActivated\",\n      get: function get() {\n        return !!this.activated;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"component\",\n      get: function get() {\n        if (!this.activated) throw new Error('Outlet is not activated');\n        return this.activated.instance;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"activatedRoute\",\n      get: function get() {\n        if (!this.activated) throw new Error('Outlet is not activated');\n        return (\n          /** @type {?} */\n          this._activatedRoute\n        );\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"activatedRouteData\",\n      get: function get() {\n        if (this._activatedRoute) {\n          return this._activatedRoute.snapshot.data;\n        }\n\n        return {};\n      }\n      /**\n       * Called when the `RouteReuseStrategy` instructs to detach the subtree\n       * @return {?}\n       */\n\n    }, {\n      key: \"detach\",\n      value: function detach() {\n        if (!this.activated) throw new Error('Outlet is not activated');\n        this.location.detach();\n        var\n        /** @type {?} */\n        cmp = this.activated;\n        this.activated = null;\n        this._activatedRoute = null;\n        return cmp;\n      }\n      /**\n       * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree\n       * @param {?} ref\n       * @param {?} activatedRoute\n       * @return {?}\n       */\n\n    }, {\n      key: \"attach\",\n      value: function attach(ref, activatedRoute) {\n        this.activated = ref;\n        this._activatedRoute = activatedRoute;\n        this.location.insert(ref.hostView);\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"deactivate\",\n      value: function deactivate() {\n        if (this.activated) {\n          var\n          /** @type {?} */\n          c = this.component;\n          this.activated.destroy();\n          this.activated = null;\n          this._activatedRoute = null;\n          this.deactivateEvents.emit(c);\n        }\n      }\n      /**\n       * @param {?} activatedRoute\n       * @param {?} resolver\n       * @return {?}\n       */\n\n    }, {\n      key: \"activateWith\",\n      value: function activateWith(activatedRoute, resolver) {\n        if (this.isActivated) {\n          throw new Error('Cannot activate an already activated outlet');\n        }\n\n        this._activatedRoute = activatedRoute;\n        var\n        /** @type {?} */\n        snapshot = activatedRoute._futureSnapshot;\n        var\n        /** @type {?} */\n        component =\n        /** @type {?} */\n\n        /** @type {?} */\n        snapshot.routeConfig.component;\n        resolver = resolver || this.resolver;\n        var\n        /** @type {?} */\n        factory = resolver.resolveComponentFactory(component);\n        var\n        /** @type {?} */\n        childContexts = this.parentContexts.getOrCreateContext(this.name).children;\n        var\n        /** @type {?} */\n        injector = new OutletInjector(activatedRoute, childContexts, this.location.injector);\n        this.activated = this.location.createComponent(factory, this.location.length, injector); // Calling `markForCheck` to make sure we will run the change detection when the\n        // `RouterOutlet` is inside a `ChangeDetectionStrategy.OnPush` component.\n\n        this.changeDetector.markForCheck();\n        this.activateEvents.emit(this.activated.instance);\n      }\n    }]);\n\n    return RouterOutlet;\n  }();\n\n  RouterOutlet.ɵfac = function RouterOutlet_Factory(t) {\n    return new (t || RouterOutlet)(ɵngcc0.ɵɵdirectiveInject(ChildrenOutletContexts), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵinjectAttribute('name'), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef));\n  };\n\n  RouterOutlet.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: RouterOutlet,\n    selectors: [[\"router-outlet\"]],\n    outputs: {\n      activateEvents: \"activate\",\n      deactivateEvents: \"deactivate\"\n    },\n    exportAs: [\"outlet\"]\n  });\n  /** @nocollapse */\n\n  return RouterOutlet;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar OutletInjector = /*#__PURE__*/function () {\n  /**\n   * @param {?} route\n   * @param {?} childContexts\n   * @param {?} parent\n   */\n  function OutletInjector(route, childContexts, parent) {\n    _classCallCheck(this, OutletInjector);\n\n    this.route = route;\n    this.childContexts = childContexts;\n    this.parent = parent;\n  }\n  /**\n   * @param {?} token\n   * @param {?=} notFoundValue\n   * @return {?}\n   */\n\n\n  _createClass(OutletInjector, [{\n    key: \"get\",\n    value: function get(token, notFoundValue) {\n      if (token === ActivatedRoute) {\n        return this.route;\n      }\n\n      if (token === ChildrenOutletContexts) {\n        return this.childContexts;\n      }\n\n      return this.parent.get(token, notFoundValue);\n    }\n  }]);\n\n  return OutletInjector;\n}();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n*@license\n*Copyright Google Inc. All Rights Reserved.\n*\n*Use of this source code is governed by an MIT-style license that can be\n*found in the LICENSE file at https://angular.io/license\n*/\n\n/**\n * \\@whatItDoes Provides a preloading strategy.\n *\n * \\@experimental\n * @abstract\n */\n\n\nvar PreloadingStrategy = /*#__PURE__*/_createClass(function PreloadingStrategy() {\n  _classCallCheck(this, PreloadingStrategy);\n});\n/**\n * \\@whatItDoes Provides a preloading strategy that preloads all modules as quickly as possible.\n *\n * \\@howToUse\n *\n * ```\n * RouteModule.forRoot(ROUTES, {preloadingStrategy: PreloadAllModules})\n * ```\n *\n * \\@experimental\n */\n\n\nvar PreloadAllModules = /*#__PURE__*/function () {\n  function PreloadAllModules() {\n    _classCallCheck(this, PreloadAllModules);\n  }\n\n  _createClass(PreloadAllModules, [{\n    key: \"preload\",\n    value:\n    /**\n     * @param {?} route\n     * @param {?} fn\n     * @return {?}\n     */\n    function preload(route, fn) {\n      return _catch.call(fn(), function () {\n        return of(null);\n      });\n    }\n  }]);\n\n  return PreloadAllModules;\n}();\n/**\n * \\@whatItDoes Provides a preloading strategy that does not preload any modules.\n *\n * \\@description\n *\n * This strategy is enabled by default.\n *\n * \\@experimental\n */\n\n\nvar NoPreloading = /*#__PURE__*/function () {\n  function NoPreloading() {\n    _classCallCheck(this, NoPreloading);\n  }\n\n  _createClass(NoPreloading, [{\n    key: \"preload\",\n    value:\n    /**\n     * @param {?} route\n     * @param {?} fn\n     * @return {?}\n     */\n    function preload(route, fn) {\n      return of(null);\n    }\n  }]);\n\n  return NoPreloading;\n}();\n/**\n * The preloader optimistically loads all router configurations to\n * make navigations into lazily-loaded sections of the application faster.\n *\n * The preloader runs in the background. When the router bootstraps, the preloader\n * starts listening to all navigation events. After every such event, the preloader\n * will check if any configurations can be loaded lazily.\n *\n * If a route is protected by `canLoad` guards, the preloaded will not load it.\n *\n * \\@stable\n */\n\n\nvar RouterPreloader = /*#__PURE__*/(function () {\n  var RouterPreloader = /*#__PURE__*/function () {\n    /**\n     * @param {?} router\n     * @param {?} moduleLoader\n     * @param {?} compiler\n     * @param {?} injector\n     * @param {?} preloadingStrategy\n     */\n    function RouterPreloader(router, moduleLoader, compiler, injector, preloadingStrategy) {\n      _classCallCheck(this, RouterPreloader);\n\n      this.router = router;\n      this.injector = injector;\n      this.preloadingStrategy = preloadingStrategy;\n\n      var\n      /** @type {?} */\n      onStartLoad = function onStartLoad(r) {\n        return router.triggerEvent(new RouteConfigLoadStart(r));\n      };\n\n      var\n      /** @type {?} */\n      onEndLoad = function onEndLoad(r) {\n        return router.triggerEvent(new RouteConfigLoadEnd(r));\n      };\n\n      this.loader = new RouterConfigLoader(moduleLoader, compiler, onStartLoad, onEndLoad);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    _createClass(RouterPreloader, [{\n      key: \"setUpPreloading\",\n      value: function setUpPreloading() {\n        var _this50 = this;\n\n        var\n        /** @type {?} */\n        navigations$ = filter.call(this.router.events, function (e) {\n          return e instanceof NavigationEnd;\n        });\n        this.subscription = concatMap.call(navigations$, function () {\n          return _this50.preload();\n        }).subscribe(function () {});\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"preload\",\n      value: function preload() {\n        var\n        /** @type {?} */\n        ngModule = this.injector.get(NgModuleRef);\n        return this.processRoutes(ngModule, this.router.config);\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this.subscription.unsubscribe();\n      }\n      /**\n       * @param {?} ngModule\n       * @param {?} routes\n       * @return {?}\n       */\n\n    }, {\n      key: \"processRoutes\",\n      value: function processRoutes(ngModule, routes) {\n        var\n        /** @type {?} */\n        res = [];\n\n        var _iterator10 = _createForOfIteratorHelper(routes),\n            _step10;\n\n        try {\n          for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n            var route = _step10.value;\n\n            // we already have the config loaded, just recurse\n            if (route.loadChildren && !route.canLoad && route._loadedConfig) {\n              var\n              /** @type {?} */\n              childConfig = route._loadedConfig;\n              res.push(this.processRoutes(childConfig.module, childConfig.routes)); // no config loaded, fetch the config\n            } else if (route.loadChildren && !route.canLoad) {\n              res.push(this.preloadConfig(ngModule, route)); // recurse into children\n            } else if (route.children) {\n              res.push(this.processRoutes(ngModule, route.children));\n            }\n          }\n        } catch (err) {\n          _iterator10.e(err);\n        } finally {\n          _iterator10.f();\n        }\n\n        return mergeAll.call(from(res));\n      }\n      /**\n       * @param {?} ngModule\n       * @param {?} route\n       * @return {?}\n       */\n\n    }, {\n      key: \"preloadConfig\",\n      value: function preloadConfig(ngModule, route) {\n        var _this51 = this;\n\n        return this.preloadingStrategy.preload(route, function () {\n          var\n          /** @type {?} */\n          loaded$ = _this51.loader.load(ngModule.injector, route);\n\n          return mergeMap.call(loaded$, function (config) {\n            route._loadedConfig = config;\n            return _this51.processRoutes(config.module, config.routes);\n          });\n        });\n      }\n    }]);\n\n    return RouterPreloader;\n  }();\n\n  RouterPreloader.ɵfac = function RouterPreloader_Factory(t) {\n    return new (t || RouterPreloader)(ɵngcc0.ɵɵinject(Router), ɵngcc0.ɵɵinject(NgModuleFactoryLoader), ɵngcc0.ɵɵinject(ɵngcc0.Compiler), ɵngcc0.ɵɵinject(ɵngcc0.Injector), ɵngcc0.ɵɵinject(PreloadingStrategy));\n  };\n\n  RouterPreloader.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: RouterPreloader,\n    factory: RouterPreloader.ɵfac\n  });\n  /** @nocollapse */\n\n  return RouterPreloader;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * \\@whatItDoes Contains a list of directives\n * \\@stable\n */\n\n\nvar ROUTER_DIRECTIVES = [RouterOutlet, RouterLink, RouterLinkWithHref, RouterLinkActive];\n/**\n * \\@whatItDoes Is used in DI to configure the router.\n * \\@stable\n */\n\nvar ROUTER_CONFIGURATION = /*#__PURE__*/new InjectionToken('ROUTER_CONFIGURATION');\n/**\n * \\@docsNotRequired\n */\n\nvar ROUTER_FORROOT_GUARD = /*#__PURE__*/new InjectionToken('ROUTER_FORROOT_GUARD');\nvar ROUTER_PROVIDERS = [Location, {\n  provide: UrlSerializer,\n  useClass: DefaultUrlSerializer\n}, {\n  provide: Router,\n  useFactory: setupRouter,\n  deps: [ApplicationRef, UrlSerializer, ChildrenOutletContexts, Location, Injector, NgModuleFactoryLoader, Compiler, ROUTES, ROUTER_CONFIGURATION, [UrlHandlingStrategy, /*#__PURE__*/new Optional()], [RouteReuseStrategy, /*#__PURE__*/new Optional()]]\n}, ChildrenOutletContexts, {\n  provide: ActivatedRoute,\n  useFactory: rootRoute,\n  deps: [Router]\n}, {\n  provide: NgModuleFactoryLoader,\n  useClass: SystemJsNgModuleLoader\n}, RouterPreloader, NoPreloading, PreloadAllModules, {\n  provide: ROUTER_CONFIGURATION,\n  useValue: {\n    enableTracing: false\n  }\n}];\n/**\n * @return {?}\n */\n\nfunction routerNgProbeToken() {\n  return new NgProbeToken('Router', Router);\n}\n/**\n * \\@whatItDoes Adds router directives and providers.\n *\n * \\@howToUse\n *\n * RouterModule can be imported multiple times: once per lazily-loaded bundle.\n * Since the router deals with a global shared resource--location, we cannot have\n * more than one router service active.\n *\n * That is why there are two ways to create the module: `RouterModule.forRoot` and\n * `RouterModule.forChild`.\n *\n * * `forRoot` creates a module that contains all the directives, the given routes, and the router\n *   service itself.\n * * `forChild` creates a module that contains all the directives and the given routes, but does not\n *   include the router service.\n *\n * When registered at the root, the module should be used as follows\n *\n * ```\n * \\@NgModule({\n *   imports: [RouterModule.forRoot(ROUTES)]\n * })\n * class MyNgModule {}\n * ```\n *\n * For submodules and lazy loaded submodules the module should be used as follows:\n *\n * ```\n * \\@NgModule({\n *   imports: [RouterModule.forChild(ROUTES)]\n * })\n * class MyNgModule {}\n * ```\n *\n * \\@description\n *\n * Managing state transitions is one of the hardest parts of building applications. This is\n * especially true on the web, where you also need to ensure that the state is reflected in the URL.\n * In addition, we often want to split applications into multiple bundles and load them on demand.\n * Doing this transparently is not trivial.\n *\n * The Angular router solves these problems. Using the router, you can declaratively specify\n * application states, manage state transitions while taking care of the URL, and load bundles on\n * demand.\n *\n * [Read this developer guide](https://angular.io/docs/ts/latest/guide/router.html) to get an\n * overview of how the router should be used.\n *\n * \\@stable\n */\n\n\nvar RouterModule = /*#__PURE__*/(function () {\n  var RouterModule = /*#__PURE__*/function () {\n    /**\n     * @param {?} guard\n     * @param {?} router\n     */\n    function RouterModule(guard, router) {\n      _classCallCheck(this, RouterModule);\n    }\n    /**\n     * Creates a module with all the router providers and directives. It also optionally sets up an\n     * application listener to perform an initial navigation.\n     *\n     * Options (see {\\@link ExtraOptions}):\n     * * `enableTracing` makes the router log all its internal events to the console.\n     * * `useHash` enables the location strategy that uses the URL fragment instead of the history\n     * API.\n     * * `initialNavigation` disables the initial navigation.\n     * * `errorHandler` provides a custom error handler.\n     * * `preloadingStrategy` configures a preloading strategy (see {\\@link PreloadAllModules}).\n     * * `onSameUrlNavigation` configures how the router handles navigation to the current URL. See\n     * {\\@link ExtraOptions} for more details.\n     * @param {?} routes\n     * @param {?=} config\n     * @return {?}\n     */\n\n\n    _createClass(RouterModule, null, [{\n      key: \"forRoot\",\n      value: function forRoot(routes, config) {\n        return {\n          ngModule: RouterModule,\n          providers: [ROUTER_PROVIDERS, provideRoutes(routes), {\n            provide: ROUTER_FORROOT_GUARD,\n            useFactory: provideForRootGuard,\n            deps: [[Router, new Optional(), new SkipSelf()]]\n          }, {\n            provide: ROUTER_CONFIGURATION,\n            useValue: config ? config : {}\n          }, {\n            provide: LocationStrategy,\n            useFactory: provideLocationStrategy,\n            deps: [PlatformLocation, [new Inject(APP_BASE_HREF), new Optional()], ROUTER_CONFIGURATION]\n          }, {\n            provide: PreloadingStrategy,\n            useExisting: config && config.preloadingStrategy ? config.preloadingStrategy : NoPreloading\n          }, {\n            provide: NgProbeToken,\n            multi: true,\n            useFactory: routerNgProbeToken\n          }, provideRouterInitializer()]\n        };\n      }\n      /**\n       * Creates a module with all the router directives and a provider registering routes.\n       * @param {?} routes\n       * @return {?}\n       */\n\n    }, {\n      key: \"forChild\",\n      value: function forChild(routes) {\n        return {\n          ngModule: RouterModule,\n          providers: [provideRoutes(routes)]\n        };\n      }\n    }]);\n\n    return RouterModule;\n  }();\n\n  RouterModule.ɵfac = function RouterModule_Factory(t) {\n    return new (t || RouterModule)(ɵngcc0.ɵɵinject(ROUTER_FORROOT_GUARD, 8), ɵngcc0.ɵɵinject(Router, 8));\n  };\n\n  RouterModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: RouterModule\n  });\n  RouterModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\n  /** @nocollapse */\n\n  return RouterModule;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(RouterModule, {\n    declarations: [RouterOutlet, RouterLink, RouterLinkWithHref, RouterLinkActive],\n    exports: [RouterOutlet, RouterLink, RouterLinkWithHref, RouterLinkActive]\n  });\n})();\n/**\n * @param {?} platformLocationStrategy\n * @param {?} baseHref\n * @param {?=} options\n * @return {?}\n */\n\n\nfunction provideLocationStrategy(platformLocationStrategy, baseHref) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return options.useHash ? new HashLocationStrategy(platformLocationStrategy, baseHref) : new PathLocationStrategy(platformLocationStrategy, baseHref);\n}\n/**\n * @param {?} router\n * @return {?}\n */\n\n\nfunction provideForRootGuard(router) {\n  if (router) {\n    throw new Error(\"RouterModule.forRoot() called twice. Lazy loaded modules should use RouterModule.forChild() instead.\");\n  }\n\n  return 'guarded';\n}\n/**\n * \\@whatItDoes Registers routes.\n *\n * \\@howToUse\n *\n * ```\n * \\@NgModule({\n *   imports: [RouterModule.forChild(ROUTES)],\n *   providers: [provideRoutes(EXTRA_ROUTES)]\n * })\n * class MyNgModule {}\n * ```\n *\n * \\@stable\n * @param {?} routes\n * @return {?}\n */\n\n\nfunction provideRoutes(routes) {\n  return [{\n    provide: ANALYZE_FOR_ENTRY_COMPONENTS,\n    multi: true,\n    useValue: routes\n  }, {\n    provide: ROUTES,\n    multi: true,\n    useValue: routes\n  }];\n}\n/**\n * \\@whatItDoes Represents options to configure the router.\n *\n * \\@stable\n * @record\n */\n\n/**\n * @param {?} ref\n * @param {?} urlSerializer\n * @param {?} contexts\n * @param {?} location\n * @param {?} injector\n * @param {?} loader\n * @param {?} compiler\n * @param {?} config\n * @param {?=} opts\n * @param {?=} urlHandlingStrategy\n * @param {?=} routeReuseStrategy\n * @return {?}\n */\n\n\nfunction setupRouter(ref, urlSerializer, contexts, location, injector, loader, compiler, config) {\n  var opts = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : {};\n  var urlHandlingStrategy = arguments.length > 9 ? arguments[9] : undefined;\n  var routeReuseStrategy = arguments.length > 10 ? arguments[10] : undefined;\n  var\n  /** @type {?} */\n  router = new Router(null, urlSerializer, contexts, location, injector, loader, compiler, flatten(config));\n\n  if (urlHandlingStrategy) {\n    router.urlHandlingStrategy = urlHandlingStrategy;\n  }\n\n  if (routeReuseStrategy) {\n    router.routeReuseStrategy = routeReuseStrategy;\n  }\n\n  if (opts.errorHandler) {\n    router.errorHandler = opts.errorHandler;\n  }\n\n  if (opts.enableTracing) {\n    var\n    /** @type {?} */\n    dom = ɵgetDOM();\n    router.events.subscribe(function (e) {\n      dom.logGroup(\"Router Event: \".concat(\n      /** @type {?} */\n      e.constructor.name));\n      dom.log(e.toString());\n      dom.log(e);\n      dom.logGroupEnd();\n    });\n  }\n\n  if (opts.onSameUrlNavigation) {\n    router.onSameUrlNavigation = opts.onSameUrlNavigation;\n  }\n\n  if (opts.paramsInheritanceStrategy) {\n    router.paramsInheritanceStrategy = opts.paramsInheritanceStrategy;\n  }\n\n  return router;\n}\n/**\n * @param {?} router\n * @return {?}\n */\n\n\nfunction rootRoute(router) {\n  return router.routerState.root;\n}\n/**\n * To initialize the router properly we need to do in two steps:\n *\n * We need to start the navigation in a APP_INITIALIZER to block the bootstrap if\n * a resolver or a guards executes asynchronously. Second, we need to actually run\n * activation in a BOOTSTRAP_LISTENER. We utilize the afterPreactivation\n * hook provided by the router to do that.\n *\n * The router navigation starts, reaches the point when preactivation is done, and then\n * pauses. It waits for the hook to be resolved. We then resolve it only in a bootstrap listener.\n */\n\n\nvar RouterInitializer = /*#__PURE__*/(function () {\n  var RouterInitializer = /*#__PURE__*/function () {\n    /**\n     * @param {?} injector\n     */\n    function RouterInitializer(injector) {\n      _classCallCheck(this, RouterInitializer);\n\n      this.injector = injector;\n      this.initNavigation = false;\n      this.resultOfPreactivationDone = new Subject();\n    }\n    /**\n     * @return {?}\n     */\n\n\n    _createClass(RouterInitializer, [{\n      key: \"appInitializer\",\n      value: function appInitializer() {\n        var _this52 = this;\n\n        var\n        /** @type {?} */\n        p = this.injector.get(LOCATION_INITIALIZED, Promise.resolve(null));\n        return p.then(function () {\n          var\n          /** @type {?} */\n          resolve =\n          /** @type {?} */\n          null;\n          var\n          /** @type {?} */\n          res = new Promise(function (r) {\n            return resolve = r;\n          });\n\n          var\n          /** @type {?} */\n          router = _this52.injector.get(Router);\n\n          var\n          /** @type {?} */\n          opts = _this52.injector.get(ROUTER_CONFIGURATION);\n\n          if (_this52.isLegacyDisabled(opts) || _this52.isLegacyEnabled(opts)) {\n            resolve(true);\n          } else if (opts.initialNavigation === 'disabled') {\n            router.setUpLocationChangeListener();\n            resolve(true);\n          } else if (opts.initialNavigation === 'enabled') {\n            router.hooks.afterPreactivation = function () {\n              // only the initial navigation should be delayed\n              if (!_this52.initNavigation) {\n                _this52.initNavigation = true;\n                resolve(true);\n                return _this52.resultOfPreactivationDone; // subsequent navigations should not be delayed\n              } else {\n                return (\n                  /** @type {?} */\n                  of(null)\n                );\n              }\n            };\n\n            router.initialNavigation();\n          } else {\n            throw new Error(\"Invalid initialNavigation options: '\".concat(opts.initialNavigation, \"'\"));\n          }\n\n          return res;\n        });\n      }\n      /**\n       * @param {?} bootstrappedComponentRef\n       * @return {?}\n       */\n\n    }, {\n      key: \"bootstrapListener\",\n      value: function bootstrapListener(bootstrappedComponentRef) {\n        var\n        /** @type {?} */\n        opts = this.injector.get(ROUTER_CONFIGURATION);\n        var\n        /** @type {?} */\n        preloader = this.injector.get(RouterPreloader);\n        var\n        /** @type {?} */\n        router = this.injector.get(Router);\n        var\n        /** @type {?} */\n        ref = this.injector.get(ApplicationRef);\n\n        if (bootstrappedComponentRef !== ref.components[0]) {\n          return;\n        }\n\n        if (this.isLegacyEnabled(opts)) {\n          router.initialNavigation();\n        } else if (this.isLegacyDisabled(opts)) {\n          router.setUpLocationChangeListener();\n        }\n\n        preloader.setUpPreloading();\n        router.resetRootComponentType(ref.componentTypes[0]);\n        this.resultOfPreactivationDone.next(\n        /** @type {?} */\n        null);\n        this.resultOfPreactivationDone.complete();\n      }\n      /**\n       * @param {?} opts\n       * @return {?}\n       */\n\n    }, {\n      key: \"isLegacyEnabled\",\n      value: function isLegacyEnabled(opts) {\n        return opts.initialNavigation === 'legacy_enabled' || opts.initialNavigation === true || opts.initialNavigation === undefined;\n      }\n      /**\n       * @param {?} opts\n       * @return {?}\n       */\n\n    }, {\n      key: \"isLegacyDisabled\",\n      value: function isLegacyDisabled(opts) {\n        return opts.initialNavigation === 'legacy_disabled' || opts.initialNavigation === false;\n      }\n    }]);\n\n    return RouterInitializer;\n  }();\n\n  RouterInitializer.ɵfac = function RouterInitializer_Factory(t) {\n    return new (t || RouterInitializer)(ɵngcc0.ɵɵinject(ɵngcc0.Injector));\n  };\n\n  RouterInitializer.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: RouterInitializer,\n    factory: RouterInitializer.ɵfac\n  });\n  /** @nocollapse */\n\n  return RouterInitializer;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @param {?} r\n * @return {?}\n */\n\n\nfunction getAppInitializer(r) {\n  return r.appInitializer.bind(r);\n}\n/**\n * @param {?} r\n * @return {?}\n */\n\n\nfunction getBootstrapListener(r) {\n  return r.bootstrapListener.bind(r);\n}\n/**\n * A token for the router initializer that will be called after the app is bootstrapped.\n *\n * \\@experimental\n */\n\n\nvar ROUTER_INITIALIZER = /*#__PURE__*/new InjectionToken('Router Initializer');\n/**\n * @return {?}\n */\n\nfunction provideRouterInitializer() {\n  return [RouterInitializer, {\n    provide: APP_INITIALIZER,\n    multi: true,\n    useFactory: getAppInitializer,\n    deps: [RouterInitializer]\n  }, {\n    provide: ROUTER_INITIALIZER,\n    useFactory: getBootstrapListener,\n    deps: [RouterInitializer]\n  }, {\n    provide: APP_BOOTSTRAP_LISTENER,\n    multi: true,\n    useExisting: ROUTER_INITIALIZER\n  }];\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * \\@stable\n */\n\n\nvar VERSION = /*#__PURE__*/new Version('5.2.11');\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @module\n * @description\n * Entry point for all public APIs of this package.\n */\n// This file only reexports content of the `src` folder. Keep it that way.\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { RouterLink, RouterLinkWithHref, RouterLinkActive, RouterOutlet, ActivationEnd, ActivationStart, ChildActivationEnd, ChildActivationStart, GuardsCheckEnd, GuardsCheckStart, NavigationCancel, NavigationEnd, NavigationError, NavigationStart, ResolveEnd, ResolveStart, RouteConfigLoadEnd, RouteConfigLoadStart, RouterEvent, RoutesRecognized, RouteReuseStrategy, Router, ROUTES, ROUTER_CONFIGURATION, ROUTER_INITIALIZER, RouterModule, provideRoutes, ChildrenOutletContexts, OutletContext, NoPreloading, PreloadAllModules, PreloadingStrategy, RouterPreloader, ActivatedRoute, ActivatedRouteSnapshot, RouterState, RouterStateSnapshot, PRIMARY_OUTLET, convertToParamMap, UrlHandlingStrategy, DefaultUrlSerializer, UrlSegment, UrlSegmentGroup, UrlSerializer, UrlTree, VERSION, ROUTER_PROVIDERS as ɵROUTER_PROVIDERS, flatten as ɵflatten, ROUTER_FORROOT_GUARD as ɵa, RouterInitializer as ɵg, getAppInitializer as ɵh, getBootstrapListener as ɵi, provideForRootGuard as ɵd, provideLocationStrategy as ɵc, provideRouterInitializer as ɵj, rootRoute as ɵf, routerNgProbeToken as ɵb, setupRouter as ɵe, Tree as ɵk, TreeNode as ɵl }; //# sourceMappingURL=router.js.map","map":null,"metadata":{},"sourceType":"module"}